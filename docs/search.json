[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Wolframite Documentation",
    "section": "",
    "text": "1 Wolframite\nAn interface between Clojure and the Wolfram Language (Supports Mathematica and Wolfram Engine ).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Wolframite</span>"
    ]
  },
  {
    "objectID": "index.html#status",
    "href": "index.html#status",
    "title": "Wolframite Documentation",
    "section": "1.1 Status",
    "text": "1.1 Status\nWolframite is currently (Q2/2024) under active development again. You can keep track of what is happening in this discussion.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Wolframite</span>"
    ]
  },
  {
    "objectID": "index.html#what-is-wolframite",
    "href": "index.html#what-is-wolframite",
    "title": "Wolframite Documentation",
    "section": "1.2 What is Wolframite?",
    "text": "1.2 What is Wolframite?\nWolframite (formerly Clojuratica) brings together two of today’s most exciting tools for high-performance, parallel computation.\nClojure is a dynamic functional programming language with a compelling approach to concurrency and state, a strong cast of persistent immutable data structures, and a growing reputation for doing all the right things. Wolfram Mathematica is arguably the world’s most powerful integrated tool for numerical computation, symbolic mathematics, optimization, and visualization and is build on top of its own splendid functional programming language, Wolfram Language.\nBy linking the two:\n\nWolframite lets you write and evaluate Wolfram/Mathematica code in Clojure with full syntactic integration. Now Clojure programs can take advantage of Wolfram’s enormous range of numerical and symbolic mathematics algorithms and fast matrix algebra routines.\nWolframite provides the seamless and transparent translation of native data structures between Clojure and Wolfram. This includes high-precision numbers, matricies, N-dimensional arrays, and evaluated and unevaluated Mathematica expressions and formulae.\nWolframite lets you write Wolfram as if it was Clojure by providing Clojure functions and vars for all Wolfram symbols, including docstrings and autocompletion in your favorite IDE\n[Tentative] Wolframite facilitates the “Clojurization” of Wolfram’s existing parallel-computing capabilities. Wolfram is not designed for threads or concurrency. It has excellent support for parallel computation, but parallel evaluations are initiated from a single-threaded master kernel which blocks until all parallel evaluations return. By contrast, Wolframite includes a concurrency framework that lets multiple Clojure threads execute Wolfram expressions without blocking others. Now it is easy to run a simulation in Clojure with 1,000 independent threads asynchronously evaluating processor-intensive expressions in Wolfram. The computations will be farmed out adaptively and transparently to however many Wolfram kernels are available on any number of processor cores, either locally or across a cluster, grid, or network.\n\nNotice that you cannot run more Wolfram kernels than your license allows (see wolframite/kernel-info!)\n\n\nWolframite is open-source and targeted at applications in scientific computing, computational economics, finance, and other fields that rely on the combination of parallelized simulation and high-performance number-crunching. Wolframite gives the programmer access to Clojure’s most cutting-edge features–easy concurrency and multithreading, immutable persistent data structures, and software transactional memory—alongside Wolfram’s easy-to-use algorithms for numerics, symbolic mathematics, optimization, statistics, visualization, and image-processing.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Wolframite</span>"
    ]
  },
  {
    "objectID": "index.html#usage",
    "href": "index.html#usage",
    "title": "Wolframite Documentation",
    "section": "1.3 Usage",
    "text": "1.3 Usage\n\n1.3.1 Prerequisites:\n\n1.3.1.1 Clojure\nFirst, if you haven’t already, install the Clojure CLI toolchain (homebrew is a great way to do this if you’re on Mac or Linux, but you can just as easily use the installation scripts if you prefer).\n\n\n1.3.1.2 Mathematica or Wolfram Engine\nNext, obviously, you’ll need to ensure that you have Wolfram Engine or Mathematica installed and your license (free for W. E.) registered - make sure you can run these tools on their own before trying Wolframite.\nFirst of all, you need to initialize a connection to a Wolfram/Mathematica kernel, like this:\n(wolframite.core/start)\nThis should also find and load the JLink JAR included with your installation. Watch stdout for an INFO log message (via clojure.tools.logging) like:\n\n=== Adding path to classpath: /Applications/Wolfram Engine.app/Contents/Resources/Wolfram Player.app/Contents/SystemFiles/Links/JLink/JLink.jar ===\n\nHowever, sometimes Wolframite may fail to find the correct path automatically and needs your help. You can set the WOLFRAM_INSTALL_PATH environment variable or Java system property (the latter takes priority) to point to the correct location. Example:\nexport WOLFRAM_INSTALL_PATH=/opt/mathematica/13.1\n\n\n\n1.3.2 Getting started\nStart a REPL with Wolframite on the classpath, then initialize it:\n(require '[wolframite.core :as wl] \n         '[wolframite.wolfram :as w]) ; Wolfram symbols as Clojure vars / fns\n;; Initialize\n(wl/start) ; =&gt; nil\n;; Use it:\n(wl/eval (w/Dot [1 2 3] [4 5 6]))\n;=&gt; 32\nMore examples\n(wl/eval (w/D (w/Power 'x 2) 'x))\n;=&gt; (* 2 x)\n(wl/eval (w/ChemicalData \"Ethanol\" \"MolarMass\"))\n;=&gt; (Quantity 46.069M (* \"Grams\" (Power \"Moles\" -1)))\n\n;; Accessing WlframAlpha\n(wl/eval (w/WolframAlpha \"How many licks does it take to get to the center of a Tootsie Pop?\")) ; BEWARE: must be online\n;=&gt; [(-&gt; [[\"Input\" 1] \"Plaintext\"] \"How many licks does it take to get to the Tootsie Roll center of a Tootsie Pop?\") (-&gt; [[\"Result\" 1] \"Plaintext\"] \"3481\\n(according to student researchers at the University of Cambridge)\")]\n\n(wl/eval (w/N w/Pi 20))\n;=&gt; 3.141592653589793238462643383279502884197169399375105820285M\n\n(wl/eval (w/Map (w/fn [x] (w/Sqrt x)) [4 16]))\n;=&gt; [2 4]\nTIP: Cursive - teach it to resolve w/fn as clojure.core/fn.\nNOTE: The wolframite.wolfram (w) ns has vars for all Wolfram symbols at the time of the last release. Check w/*wolfram-kernel-name* for kernel type/version and run (wolframite.impl.wolfram-syms.write-ns/write-ns!) to generate your own wolfram ns with whatever additional symbols your Wolfram/Mathematice has, and/or with custom “aliases”.\n\n1.3.2.1 Learning Wolframite\nRead through and play with explainer.clj and demo.clj, which demonstrate most of Wolframite’s features and what you can do with Wolfram.\n\n\n1.3.2.2 Customizing Wolframite\nA big advantage of Wolframite (as opposed to its earlier incarnations) is that we can now individually tailor the user experience at the level of initialization,\n(wl/start {:aliases '{** Power}})\n(wl/eval '(** 2 5)) ; =&gt; 32\n, and function call,\n(wl/start)\n(wl/eval '(** 2 5) {:aliases '{** Power}}) ; =&gt; 32\n. Use it how you want to!\nTIP: You can also get convenience vars for your aliases in wolframite.wolfram by running something like (wolframite.impl.wolfram-syms.write-ns/write-ns! &lt;path&gt; {:aliases '{** Power}}). After you load the file, you’ll be able to use (wl/eval (w/** 2 5) {:aliases '{** Power}}).\n\n\n\n1.3.3 Clerk Integration\nExample usage: (watching for changes in a folder)\nuser&gt; (require '[clojuratica.tools.clerk-helper :as ch])\nuser&gt; (ch/clerk-watch! [\"dev/notebook\"])\n\nOpen dev/notebook/demo.clj, make a change and save.\nOpen localhost:7777 in the browser\n\n\n\n1.3.4 How does it work?\nYou compose Wolfram expressions using the convenience functions and vars from wolframite.wolfram. These are then turned first into a symbolic representation of themselves and later into a tree of JLink Expr objects and sent to a Wolfram kernel subprocess (started by wl/start) for evaluation. The result is translated back from jlink.Expr into a Clojure form. This translation allows for some additional convenience logic, such as supporting w/* instead of Times.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Wolframite</span>"
    ]
  },
  {
    "objectID": "index.html#dependencies",
    "href": "index.html#dependencies",
    "title": "Wolframite Documentation",
    "section": "1.4 Dependencies",
    "text": "1.4 Dependencies\nWolframite requires Wolfram’s Java integration library JLink, which is currently only available with a Wolfram Engine or Mathematica installation. It will also need to know where the WolframKernel / MathKernel executable is, in order to be able to start the external evaluation kernel process. Normally, wl/start should be able to find these automatically, if you installed either into a standard location on Mac, Linux or Windows. However, if necessary, you can specify either with env variables / sys properties - see Prerequisites above.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Wolframite</span>"
    ]
  },
  {
    "objectID": "index.html#development",
    "href": "index.html#development",
    "title": "Wolframite Documentation",
    "section": "1.5 Development",
    "text": "1.5 Development\n\n1.5.1 Running tests\nTo run tests from the command line, you need to add JLink to the classpath (only REPL supports dynamically loading jars) - create a ./symlink-jlink.jar symlink and then run the tests:\nclojure -X:run-tests\n\n\n1.5.2 Deployment\nBuild the jar with clojure -T:build jar then deploy with env CLOJARS_USERNAME=&lt;tbd&gt; CLOJARS_PASSWORD=&lt;clojars-token&gt; clojure -T:build deploy\nNote: You need to log in to Clojars and generate a deployment token. You also need to be added to the SciCloj group there by an admin.\n\n1.5.2.1 Documentation\nDocumentation is written as literal programming sources in the notebooks directory and turned into HTML under docs using Clay and Quarto.\nTo render a single namespace/page, require Clay and run (clay/make! {:source-path \"&lt;path to the file&gt;\"\"}). Tip: You can also do this without quarto - just add :run-quarto false to the options.\nTo build the whole site, run clojure -T:build build-site.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Wolframite</span>"
    ]
  },
  {
    "objectID": "index.html#authors",
    "href": "index.html#authors",
    "title": "Wolframite Documentation",
    "section": "1.6 Authors",
    "text": "1.6 Authors\nThe original Clojuratica was created by Garth Sheldon-Coulson, a graduate student at the Massachusetts Institute of Technology and Harvard Law School. See the Community page to find out how to contribute to Clojuratica, suggest features, report bugs, or ask general questions.\nOngoing maintenance and development over the years have been thanks to * Steve Chan * Dan Farmer * Norman Richards\nClojuratica has been turned into Wolframite and further maintained by:\n\nPawel Ceranka\nThomas Clark\nJakub Holý\n\nThe project is now being maintained as part of the SciCloj project.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Wolframite</span>"
    ]
  },
  {
    "objectID": "index.html#contact",
    "href": "index.html#contact",
    "title": "Wolframite Documentation",
    "section": "1.7 Contact",
    "text": "1.7 Contact\nIf you would like to contact the maintainers or otherwise seek help from the community then please drop a message into our zulip channel or contact the team at SciCloj.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Wolframite</span>"
    ]
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "Wolframite Documentation",
    "section": "1.8 License",
    "text": "1.8 License\nDistributed under the Mozilla Public License either version 2.0 or (at your option) any later version.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Wolframite</span>"
    ]
  },
  {
    "objectID": "index.html#legal",
    "href": "index.html#legal",
    "title": "Wolframite Documentation",
    "section": "1.9 Legal",
    "text": "1.9 Legal\nThe product names used in this website are for identification purposes only. All trademarks and registered trademarks, including “Wolfram Mathematica,” are the property of their respective owners. Wolframite is not a product of Wolfram Research. The software on this site is provided “as-is,” without any express or implied warranty.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Wolframite</span>"
    ]
  },
  {
    "objectID": "index.html#further-documentation",
    "href": "index.html#further-documentation",
    "title": "Wolframite Documentation",
    "section": "1.10 Further documentation",
    "text": "1.10 Further documentation\nSee the book content menu on the left side\n\nsource: notebooks/index.clj",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Wolframite</span>"
    ]
  },
  {
    "objectID": "demo.html",
    "href": "demo.html",
    "title": "2  Wolframite demo",
    "section": "",
    "text": "3 Demonstration\nA brief demonstration of Wolframite can do. We suggest reading it, but you can also jump to either of the following chapters.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Wolframite demo</span>"
    ]
  },
  {
    "objectID": "demo.html#init",
    "href": "demo.html#init",
    "title": "2  Wolframite demo",
    "section": "3.1 Init",
    "text": "3.1 Init\nFirst, we must initialize Wolframite and connect it to a Wolfram kernel, which will perform the computations:\n\n(wl/start)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Wolframite demo</span>"
    ]
  },
  {
    "objectID": "demo.html#base-example",
    "href": "demo.html#base-example",
    "title": "2  Wolframite demo",
    "section": "3.2 Base example",
    "text": "3.2 Base example\n\n(wl/eval '(Dot [1 2 3] [4 5 6]))\n\n\n32",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Wolframite demo</span>"
    ]
  },
  {
    "objectID": "demo.html#strings-of-wl-code",
    "href": "demo.html#strings-of-wl-code",
    "title": "2  Wolframite demo",
    "section": "3.3 Strings of WL code",
    "text": "3.3 Strings of WL code\n\n(wl/eval \"{1 , 2, 3} . {4, 5, 6}\")\n\n\n32",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Wolframite demo</span>"
    ]
  },
  {
    "objectID": "demo.html#def-intern-wl-fns-i.e.-effectively-define-wl-fns-as-clojure-fns",
    "href": "demo.html#def-intern-wl-fns-i.e.-effectively-define-wl-fns-as-clojure-fns",
    "title": "2  Wolframite demo",
    "section": "3.4 Def / intern WL fns, i.e. effectively define WL fns as clojure fns:",
    "text": "3.4 Def / intern WL fns, i.e. effectively define WL fns as clojure fns:\n\n(def W:Plus (parse/parse-fn 'Plus {:jlink-instance (wolframite.impl.jlink-instance/get)}))\n\n\n(W:Plus 1 2 3)\n\n\n6\n\n… and call it\n\n(def greetings\n  (wl/eval\n   (w/fn [x] (w/StringJoin \"Hello, \" x \"! This is a Mathematica function's output.\"))))\n\n\n(greetings \"Stephen\")\n\n\n\"Hello, Stephen! This is a Mathematica function's output.\"",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Wolframite demo</span>"
    ]
  },
  {
    "objectID": "demo.html#bidirectional-translation",
    "href": "demo.html#bidirectional-translation",
    "title": "2  Wolframite demo",
    "section": "3.5 Bidirectional translation",
    "text": "3.5 Bidirectional translation\n(Somewhat experimental, especially in the wl-&gt;clj direction)\n\n(wl/-&gt;clj \"GridGraph[{5, 5}]\")\n\n\n(GridGraph [5 5])\n\n\n(wl/-&gt;wl (w/GridGraph [5 5]) {:output-fn str})\n\n\n\"GridGraph[{5, 5}]\"",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Wolframite demo</span>"
    ]
  },
  {
    "objectID": "demo.html#graphics",
    "href": "demo.html#graphics",
    "title": "2  Wolframite demo",
    "section": "3.6 Graphics",
    "text": "3.6 Graphics\nGridGraph[{5, 5}]\nGridGraph[{5, 5}]\nChemicalData[\"Ethanol\", \"StructureDiagram\"]",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Wolframite demo</span>"
    ]
  },
  {
    "objectID": "demo.html#more-working-examples",
    "href": "demo.html#more-working-examples",
    "title": "2  Wolframite demo",
    "section": "3.7 More Working Examples",
    "text": "3.7 More Working Examples\n\n(wl/eval (w/GeoNearest (w/Entity \"Ocean\") w/Here))\n\n\n[:entity.ocean/skagerrak]\n\nTODO: Make this work with view as well.\nTextStructure[\"The cat sat on the mat.\"]",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Wolframite demo</span>"
    ]
  },
  {
    "objectID": "demo.html#wolfram-alpha",
    "href": "demo.html#wolfram-alpha",
    "title": "2  Wolframite demo",
    "section": "3.8 Wolfram Alpha",
    "text": "3.8 Wolfram Alpha\n\n(wl/eval (w/WolframAlpha \"number of moons of Saturn\" \"Result\"))\n\n\n(Quantity 145 (IndependentUnit \"moons\"))\n\nWolframAlpha[\"number of moons of Saturn\", \"Result\"]\n\nsource: notebooks/demo.clj",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Wolframite demo</span>"
    ]
  },
  {
    "objectID": "for_scientists.index.html",
    "href": "for_scientists.index.html",
    "title": "3  Wolframite for scientists",
    "section": "",
    "text": "3.1 Abstract\nWe introduce you, the motivated scientist (likely the mathematical sort), to using the Wolfram programming language as a Clojure library. Following some brief inspiration (why on earth should you do this?), and getting started notes, we then outline a ‘real’ workflow using the example of optical cavities.",
    "crumbs": [
      "For Scientists",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Wolframite for scientists</span>"
    ]
  },
  {
    "objectID": "for_scientists.index.html#motivation---why-on-earth",
    "href": "for_scientists.index.html#motivation---why-on-earth",
    "title": "3  Wolframite for scientists",
    "section": "3.2 Motivation - Why on earth?",
    "text": "3.2 Motivation - Why on earth?\nThe Wolfram programming language is ‘best-in-class’ for certain specialist tasks, like manipulating equations, but would you really want to use a language with 6000 functions in a single global namespace to do a normal project, like building a website? Clojure, on the other-hand, is a first-class, general-purpose, programming language whose core namespace and dynamical, functional, paradigm is well suited to data exploration and manipulation. So why don’t we call Wolfram from Clojure? It seems like the atypical best of both worlds.",
    "crumbs": [
      "For Scientists",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Wolframite for scientists</span>"
    ]
  },
  {
    "objectID": "for_scientists.index.html#getting-started-for-scientists",
    "href": "for_scientists.index.html#getting-started-for-scientists",
    "title": "3  Wolframite for scientists",
    "section": "3.3 Getting Started (for scientists)",
    "text": "3.3 Getting Started (for scientists)\nThis tutorial aims to be as comprehensive as possible for the average user and, as such, is not concise. There are other quick-fire instructions available at (REF). If you still insist on working through this document, you can always search through the text for the relevant advice or examples. We won’t judge you!\n\n3.3.1 Clojure\nThere are many useful online tools for getting started with Clojure. For an overview of the language itself, see REF. If you’d like to try it out in practice then jump in with the koans. If you’d like to see why a physicist might be interested in Clojure then have a look here.\n\n3.3.1.1 Notation\nFor those who are still fairly new to clojure, the first thing to get used to is the style of notation. It might seem strange at first, but a functional LisP can be more efficient (symbolically) than a lot of object-oriented languages and even standard mathematical notation. For example, why write 1+1+1+2 and not (+ 1 1 1 2)? Theoretically, they have the same number of characters and yet even here it’s arguable that the signal to noise ratio is higher for the second one. Where the second form really shines however, is in it’s scalability. As soon as you add another operator, e.g. 1+1+1+2/3, we have a problem. Okay so you made it through primary school and know that 1+1+1+2/3 is really 1+1+1+(2/3) and not (1+1+1+2)/3, but the mental complexity is still there, you’re just used to it. If we introduce another operator, e.g. 1+1+1+2✝3, now what do you do? The truth is that if we stick to one simple rule, i.e. use brackets, then we completely solve a whole range of problems in advance, with the ‘cost’ of having to write two characters. In fact, although it might not be obvious, the Wolfram language is actually inspired by/built on the LisP syntax (underneath). The outer layer is just to make it look more like the inefficient notation that mathematicians already know and love…\nIn summary, BODMAS is six rules and incomplete. (function argument …) is a single rule and complete. Be kind to yourself, just write (+ 1 1 1 (/ 2 3)) :). If you’re still unconvinced about the benefits of a simple syntax then consider how easy it is in LisP to generate/generalize your source code with macros.\n\n\n\n3.3.2 Data science\nIf you’re sold on Clojure and interested in problems close to data science then an overview of some of the key analysis libraries can be found here (REF). If you’re ready to use Wolfram, then read on!",
    "crumbs": [
      "For Scientists",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Wolframite for scientists</span>"
    ]
  },
  {
    "objectID": "for_scientists.index.html#wolfram-basics",
    "href": "for_scientists.index.html#wolfram-basics",
    "title": "3  Wolframite for scientists",
    "section": "3.4 Wolfram basics",
    "text": "3.4 Wolfram basics\n\n3.4.1 Let’s define our terms!\nOne of the really nice things about using Wolfram as a library is that our middle man can simplify verbose terms like (w/Power ’x 2) to (w/**2 ’x), for readability. What’s even nicer however, is that we can make our own symbolic shortcuts: the setup is your own!\nWe mention this here because the best time to define your terms is at the beginning. We define some aliases below, where the first few give you an insight into how I’d have changed some of the wolfram symbols for symbolic expressiveness and ease of use. The last two go a step furter. Here, we make use of Clojure’s modernity and all round good decision to support the full unicode character set. Depending on your editor, it can be just as easy to enter these unicode characters as typing the long function name, but the real win is in the readability. Remember, we read our documents far more often than we write them (even if it’s just peer review…).\nTherefore, we enter the following.\n\n(def aliases\n  '{** Power\n    ++ Conjugate\n    _&gt; Replace\n    _&gt;&gt; ReplaceAll\n    &lt;_&gt; Expand\n    &lt;&lt;_&gt;&gt; ExpandAll\n    ++&lt;_&gt; ComplexExpand\n    &gt;_&lt; Simplify\n    &gt;&gt;_&lt;&lt; FullSimplify\n    ⮾ NonCommutativeMultiply\n    √ Sqrt\n    ∫ Integrate})\n\n\n(wl/restart {:aliases aliases})\n\nHere you see than we can define new aliases by simply using the core clojure functions/macros. This works fine, but the downside is that we have just defined symbol replacements and so won’t benefit from using these entities in macros or from editor autocompletion. For the best experience therefore, we recommend using ‘write-ns!’.\n\n(comment\n  (write/write-ns! \"src/wolframite/wolfram_extended.clj\"\n                   {:aliases aliases}))\n\nBy using this command, we can automatically create a namespace at the given location and so refer to the new symbol aliases more directly. The command appears here in a comment block to avoid unnecessary recomputation. See the ‘Literate programming’ section for an explanation.\nThe next section should probably be moved later.\n\n\n3.4.2 Access to knowledge\nWith the recent emergence of ChatGPT and similar AI systems, direct access to knowledge from free-form linguistic input is in demand. Wolfram was an early pioneer of this, launching its product, Wolfram|Alpha, in 2009. Wolfram occupies a different space however, focusing mainly on what it describes as ‘computational knowledge’. Rather than strictly using an LLM, it combines its knowledge databases with the ability to perform Wolfram operations on the retrieved data before returning the result.\nFor example, we can make both knowledge-based requests and perform complicated calculations (requires internet access).\n\n(wl/eval (w/WolframAlpha \"What is the mass of 5 rubidium atoms?\"))\n\n\n[(-&gt;\n  [[\"Input\" 1] \"Plaintext\"]\n  \"convert 5 atoms of rubidium (chemical element) to mass\")\n (-&gt; [[\"Result\" 1] \"Plaintext\"] \"709.613 yg (yoctograms)\")\n (-&gt; [[\"UnitConversion\" 1] \"Plaintext\"] \"7.09613×10^-22 grams\")\n (-&gt;\n  [[\"UnitConversion\" 2] \"Plaintext\"]\n  \"7.09613×10^-25 kg (kilograms)\")\n (-&gt;\n  [[\"UnitConversion\" 3] \"Plaintext\"]\n  \"427.339 u (unified atomic mass units)\")\n (-&gt; [[\"Interpretation\" 1] \"Plaintext\"] \"mass\")\n (-&gt;\n  [[\"CorrespondingQuantity\" 1] \"Plaintext\"]\n  \"Relativistic energy E from E = mc^2:\\n | 0.064 μJ (microjoules)\\n | 398 GeV (gigaelectronvolts)\")\n (-&gt;\n  [[\"CorrespondingQuantity\" 2] \"Plaintext\"]\n  \"Characteristic length L from L = h/(mc):\\n | 3.1 am (attometers)\\n | 3.1×10^-18 meters\")\n (-&gt;\n  [[\"CorrespondingQuantity\" 3] \"Plaintext\"]\n  \"Thermal de Broglie wavelength at 100 K from λ = h/(2πmkT)^(1/2):\\n | 8.4 pm (picometers)\")\n (-&gt;\n  [[\"CorrespondingQuantity\" 4] \"Plaintext\"]\n  \"Characteristic time T from T = h/(mc^2):\\n | 1×10^-26 seconds\")\n (-&gt;\n  [[\"CorrespondingQuantity\" 5] \"Plaintext\"]\n  \"Thermodynamic temperature T from kT = mc^2:\\n | 4.619×10^15 K (kelvins)\")\n (-&gt;\n  [[\"CorrespondingQuantity\" 6] \"Plaintext\"]\n  \"Compton frequency ν from ν = mc^2/h:\\n | 9.625×10^25 Hz (hertz)\")\n (-&gt;\n  [[\"Input\" 1] \"Input\"]\n  (HoldComplete\n   (ChemicalConvert\n    (ChemicalInstance :entity.element/rubidium (Quantity 5 \"Atoms\"))\n    (QuantityVariable \"Mass\"))))]\n\n\n(wl/eval (w/WolframAlpha \"What is the relativistic momentum of a 0.8c electron?\"))\n\n\n[(-&gt;\n  [[\"Input\" 1] \"Plaintext\"]\n  \"relativistic momentum | \\nvelocity | 0.8 c (speed of light)\\nmass | e^- (electron) (mass): 510.9989461 keV/c^2\")\n (-&gt;\n  [[\"Result\" 1] \"Plaintext\"]\n  \"momentum | 681.3 keV/c\\n= 3.641×10^-22 J s/m (joule seconds per meter)\\n= 3.641×10^-22 kg m/s (kilogram meters per second)\")\n (-&gt;\n  [[\"Equation\" 1] \"Plaintext\"]\n  \"p = (m v)/sqrt(1 - v^2/c^2) | \\np | momentum\\nv | velocity\\nm | mass\\nc | speed of light (≈ 2.998×10^8 m/s)\")\n (-&gt;\n  [[\"Input\" 1] \"Input\"]\n  (HoldComplete\n   (FormulaData\n    [\"MomentumRelativistic\" \"Velocity\"]\n    [(-&gt; \"v\" (Quantity 0.8 \"SpeedOfLight\"))\n     (-&gt;\n      \"m\"\n      (:entity.particle/electron :entity-property.particle/mass))])))\n (-&gt;\n  [[\"Result\" 1] \"Input\"]\n  (HoldComplete\n   (FormulaData\n    [\"MomentumRelativistic\" \"Velocity\"]\n    [(-&gt; \"v\" (Quantity 0.8 \"SpeedOfLight\"))\n     (-&gt;\n      \"m\"\n      (Quantity\n       510.9989461\n       (*\n        \"Kiloelectronvolts\"\n        (Power (Power \"SpeedOfLight\" 2) -1))))])))\n (-&gt;\n  [[\"Equation\" 1] \"Input\"]\n  (HoldComplete\n   (Column\n    [(FormulaData\n      [\"MomentumRelativistic\" \"Velocity\"]\n      [(-&gt; \"v\" (Quantity 0.8 \"SpeedOfLight\"))\n       (-&gt;\n        \"m\"\n        (Quantity\n         510.9989461\n         (*\n          \"Kiloelectronvolts\"\n          (Power (Power \"SpeedOfLight\" 2) -1))))])\n     (FormulaData\n      [\"MomentumRelativistic\" \"Velocity\"]\n      \"QuantityVariableTable\")])))]\n\nIn each case, Wolfram does not just provide the answer, but returns the data in different formats and units in an attempt to anticipate different usecases. This verbosity might seem frustrating, but of course adds flexibility: leaving the user free to filter or present the results in any way that they wish.\n\n\n3.4.3 Defining expressions\nRather than just querying the Wolfram servers however, the vast majority of people who use this library will want to write their own programs.\nFor those coming from Mathematica (the official, graphical front-end for the Wolfram language), a good place to start is defining expressions.\nThis is where the main cost of ‘Wolfram as a library’ lies. In a Wolfram environment, then all non-language characters are treated as global symbols by default. This works well for symbol and expression manipulation (Mathematica’s assumed raison d’être), but not for any other purpose. To successfully embed Wolfram expressions into a general purpose programming language we must make choices.\nIn this library, there are two approaches. For all official functions, the cleanest way of referring to them is to import the base symbol namespace, i.e. wolframite.wolfram or, as in this example, a customized one: wolframite.wolfram-extended. This allows the user to manipulate expressions like other clojure functions (and to access the associated Wolfram documentation from your editor) e.g.\n\n(-&gt; 2\n    (w/Power 1)\n    (w/Subtract 2))\n\n\n(Subtract (Power 2 1) 2)\n\nTo calculate/retrieve the result we then simply add ‘eval’ from the Wolframite core namespace:\n\n(-&gt; 2\n    (w/Power 1)\n    (w/Subtract 2)\n    wl/eval)\n\n\n0\n\nNote, separating expression chains from automatic eval was done for efficiency. Previously, all Wolfram expressions were individually evaluated and this was considered a performance problem.\nTo deal with general symbols, we return to one of LisPs’ strengths: controlled evaluation. Historically necessitated by LisPs’ ‘code-as-data’ paradigm, all LisPs can deal with general symbols by simply not evaluating them. This makes it easy to create and manipulate arbitrary Wolfram expressions, as we can simply treat them as unevaluated symbols.\n\n(-&gt; 'x\n    (w/** 1)\n    (w/- '5)\n    wl/eval)\n\n\n(+ -5 x)\n\nThis comes at the cost of having to ‘mark’ symbols, lists and functions manually, but it’s a choice between being unevaluated by default (e.g. Wolfram, Maple), unevaluated when marked (LisPs) or no easy to work with symbols (the vast majority of programming languages). It also comes at the cost of some ‘gotchas’ (see below), but these are avoided for the most part by using a wolframite.wolfram namespace (and ‘write-ns!’ function), as introduced in the beginning.\n\n\n3.4.4 Defining functions\nFunctions are slightly more complicated. Functions can be defined in many different ways. The easiest way is to keep functions, where appropritae, as standard Clojure expressions.\nIf you’re used to using Wolfram/Mathematica, then f[x_]:=x^2 becomes\n\n(defn square [x] (wl/eval (w/Power x 2)))\n\n\n(square 2)\n\n\n4\n\n\n(square 'x)\n\n\n(Power x 2)\n\nIf you want to define functions inside the Wolfram kernel and attach them to arbitrary symbols, then you can write\nRather than a direct alias, w/fn is a special form that allows you to define Wolfram functions in a convenient way. Note that ‘f’ is a new symbol and therefore cannot be expected to be part of wolframite.wolfram or similar namespaces. Therefore, we must call the function using an unevaluated Clojure list.\nOnce you can define your own aliases and create arbitrary expressions and functions, then you’re basically good to go. You might have noticed however, that the above function assignment used an unfamiliar symbol…\n\n\n3.4.5 Gotchas…\nThis brings us to some of the ‘gotchas’ in this library. Although we try to avoid such things, sometimes, when you’re fighting the host language, it’s just not practical. Here we will try to keep an up-to-date list of surprises that are not easy to ‘fix’.\n\n:= (SetDelayed) is actually ‘=’ in Wolframite. This is because ’:’ is a reserved character in Clojure for creating keywords. It’s worth noting though that this is possibly nicer, in a way, because ’’ looks like a placeholder, which implies a delay…\n:&gt; (RuleDelayed) similarly, is ’_&gt;’\n. (Dot) has been changed to ’&lt;*&gt;‘, in the spirit of the inner product, because’.’ is a key character in Clojure and most object-oriented systems for namespacing.\n/. (ReplaceAll) similarly, has been changed to ‘x&gt;&gt;’ (and ‘Replace’ to ‘x&gt;’ for consistency).\n=. (Unset) has also been changed to ‘=!’.\nSymbols within threading macros. After spending so much time playing with symbols, be careful of slipping into things like (-&gt; ‘x’(Power 1)) This will not work because threads are macros and so combining them with unevaluated functions will lead to unexpected errors.\nSymbols passed to Mathematica must be alphanumeric, i.e. r_2 is not allowed.",
    "crumbs": [
      "For Scientists",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Wolframite for scientists</span>"
    ]
  },
  {
    "objectID": "for_scientists.index.html#faq",
    "href": "for_scientists.index.html#faq",
    "title": "3  Wolframite for scientists",
    "section": "3.5 FAQ",
    "text": "3.5 FAQ\n\nWhy Clojure? (need some getting started references) – chaining expressions (so much better than in Wolfram)\nWhy Wolfram? thinking (and evaluating) at the level of the expression\nWhy not Emmy?\nWhy literate programming?\n\nclay, clerk\nwhy not notebooks?\n\nHow do I translate Mathematica’s syntax sugar?\n\nSince Mathematica hides its internals by default it can sometimes be difficult to work out what functions are being called. If you’re in Mathematica, you can use ‘FullForm@Unevaluated[…]’ to get a more understandable (if less concise) expression. Of course, you can also use Wolframite, i.e. (wl/-&gt;) !",
    "crumbs": [
      "For Scientists",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Wolframite for scientists</span>"
    ]
  },
  {
    "objectID": "for_scientists.index.html#function-shortcuts",
    "href": "for_scientists.index.html#function-shortcuts",
    "title": "3  Wolframite for scientists",
    "section": "3.6 Function shortcuts",
    "text": "3.6 Function shortcuts\nThe next step up from making our symbols more readable, is to make our code more readable: let’s see how some UX conveniences are built.\n\n(defn ||2\n  \"The intensity: the value times the conjugate of the value or, equivalently, the absolute value squared.\"\n  [x]\n  (w/* x (w/++ x)))\n\n\n(wl/eval (||2 (w/+ 5 (w/* 3 w/I))))\n\n\n34\n\n\n(defmacro eval-&gt;\n  \"Extends the threading macro to automatically pass the result to wolframite eval.\n\n  TODO: Should we automatically quote everything inside this?\"\n  [& xs]\n  `(-&gt; ~@xs wl/eval))\n\n\n(defmacro eval-&gt;&gt;\n  \"Extends the threading macro to automatically pass the result to wolframite eval.\n\n  TODO: Should we automatically quote everything inside this?\"\n  [& xs]\n  `(-&gt;&gt; ~@xs wl/eval))\n\n\n(defn TeX\n  \" UX fix. Passes the Wolfram expression to ToString[TeXForm[...]] as the unsuspecting traveller might not realise that 'ToString' is necessary.\n  \"\n  [tex-form]\n  (w/ToString (w/TeXForm tex-form)))\n\n\n(defmacro TeX-&gt;\n  \"Extends the threading macro to automatically pass the result to wolframite eval.\"\n  [& xs]\n  `(-&gt; ~@xs TeX wl/eval k/tex))\n\n\n(defmacro TeX-&gt;&gt;\n  \"Extends the threading macro to automatically pass the result to wolframite eval.\n  \"\n  [& xs]\n  `(-&gt;&gt; ~@xs TeX wl/eval k/tex))\n\nNow we can implicitly chain operations together and still get a nice result in the browser:\n\\[x x^*+y\\]",
    "crumbs": [
      "For Scientists",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Wolframite for scientists</span>"
    ]
  },
  {
    "objectID": "for_scientists.index.html#cavities",
    "href": "for_scientists.index.html#cavities",
    "title": "3  Wolframite for scientists",
    "section": "4.1 Cavities?",
    "text": "4.1 Cavities?\nOutside of the operating room, the most common notion of cavities is, what we might otherwise call, an optical resonator. One way of looking at it, although quantum mechanics makes this more difficult, is that an optical cavity is simply just a light trap, such that once light gets in, then it bounces around for a while before it leaves.\nFor demo purposes, our question is then ‘how can we model this?’ and ‘how does the light intensity, inside and outside of the cavity, depend on some experimental variables’?",
    "crumbs": [
      "For Scientists",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Wolframite for scientists</span>"
    ]
  },
  {
    "objectID": "for_scientists.index.html#setup",
    "href": "for_scientists.index.html#setup",
    "title": "3  Wolframite for scientists",
    "section": "4.2 Setup",
    "text": "4.2 Setup\nAssuming a simple two-mirror setup, with independent reflectivities and transmission, the system can be described as a ray oscillating between four key interfaces, as illustrated in the figure.\n\nWe must therefore consider the electric field at each interface, before solving for the intensity both inside and outside.",
    "crumbs": [
      "For Scientists",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Wolframite for scientists</span>"
    ]
  },
  {
    "objectID": "for_scientists.index.html#interfaces",
    "href": "for_scientists.index.html#interfaces",
    "title": "3  Wolframite for scientists",
    "section": "4.3 Interfaces",
    "text": "4.3 Interfaces\nSetting the incoming field amplitude to unity, then the value of the field at position one, after one round trip, is the sum of the transmission coefficient and the field travelling in the opposing direction e.g.\n\n(def E1\n  (w/+ 't1 (w/* 'r1 (w/- 'E4))))\n\nAt position two, the same field has travelled the full length of the cavity, L, and so has picked up a change in phase,\n\n(def phi\n  (w/* 'k 'L))\n\n, where k is the field wavenumber:\n\n(def E2\n  (w/* E1 (w/Exp (w/* w/I phi))))\n\nAt position three, the field undergoes reflection and so now carries an additional reflection coefficient as well as an extra π phase change.\nNote how we are able to seamlessly mix Clojure and Wolfram expressions in these expressions.\n\n(def E3\n  (w/* (w/- 'r2) E2))\n\nBy position four, the field has travelled a further distance L and so is now equal to\n\n(def E4\n  (w/* E3 (w/Exp (w/* w/I phi))))\n\n\\[\\text{r2} \\left(-e^{2 i k L}\\right) (\\text{t1}-\\text{E4} \\text{r1})\\]\n## Fields Using these expressions, we can now calculate the inner, transmitted and reflected fields of the cavity (with some subtle phase assumptions). Note how easy it is to, first of all, form an equation from a symbol ’E4 and the clojure variable E4, and, second of all, to rearrange the equation for a solution.\nSubstitution and simplification can then also be used to arrive at the transmission and reflection, respectively.\n\n(def e4 (-&gt; (w/== 'E4 E4)\n            (w/Solve 'E4)\n            w/First w/First))\n\n\n(eval-&gt; e4)\n\n\n(-&gt;\n E4\n (*\n  (Power E (* (Complex 0 2) k L))\n  r2\n  (Power (+ -1 (* (Power E (* (Complex 0 2) k L)) r1 r2)) -1)\n  t1))\n\n\n(def T (-&gt; (w/_&gt;&gt; (w/* E2 't2)\n                  e4)\n           w/&gt;&gt;_&lt;&lt;))\n\n\\[\\frac{\\text{t1} \\text{t2} e^{i k L}}{1-\\text{r1} \\text{r2} e^{2 i k L}}\\]\n\n(def R (-&gt; (w/+ (w/* E4 't1) 'r1)\n           (w/_&gt;&gt; e4)\n           w/&gt;&gt;_&lt;&lt;\n           w/Together))\n\n\\[\\frac{\\text{r1}^2 \\text{r2} e^{2 i k L}+\\text{r2} \\text{t1}^2 e^{2 i k L}-\\text{r1}}{-1+\\text{r1} \\text{r2} e^{2 i k L}}\\]",
    "crumbs": [
      "For Scientists",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Wolframite for scientists</span>"
    ]
  },
  {
    "objectID": "for_scientists.index.html#observables",
    "href": "for_scientists.index.html#observables",
    "title": "3  Wolframite for scientists",
    "section": "4.4 Observables",
    "text": "4.4 Observables\nTaking the square of the fields (using the complex conjugate), gives the corresponding observables, i.e. things that can be actually measured, for the case of no loss.\n\n(def I4 (-&gt; (w/_&gt;&gt; 'E4 e4) ||2\n            w/++&lt;_&gt;\n            w/&gt;&gt;_&lt;&lt;))\n\n\\[\\text{I4}=| \\text{E4}| ^2=\\frac{\\text{r2}^2 \\text{t1}^2}{-2 \\text{r1} \\text{r2} \\cos (2 k L)+\\text{r1}^2 \\text{r2}^2+1}\\]\n\n(def Tsq (-&gt; T ||2\n             w/++&lt;_&gt;\n             w/&gt;&gt;_&lt;&lt;))\n\n\\[T^2=\\frac{\\text{t1}^2 \\text{t2}^2}{-2 \\text{r1} \\text{r2} \\cos (2 k L)+\\text{r1}^2 \\text{r2}^2+1}\\]\n\n(def Rsq (-&gt; R ||2\n             w/++&lt;_&gt;\n             w/&gt;&gt;_&lt;&lt;\n             w/Together))\n\n\\[R^2=\\frac{-2 \\text{r1}^3 \\text{r2} \\cos (2 k L)-2 \\text{r1} \\text{r2} \\text{t1}^2 \\cos (2 k L)+\\text{r1}^4 \\text{r2}^2+2 \\text{r1}^2 \\text{r2}^2 \\text{t1}^2+\\text{r1}^2+\\text{r2}^2 \\text{t1}^4}{-2 \\text{r1} \\text{r2} \\cos (2 k L)+\\text{r1}^2 \\text{r2}^2+1}\\]",
    "crumbs": [
      "For Scientists",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Wolframite for scientists</span>"
    ]
  },
  {
    "objectID": "for_scientists.index.html#observables-with-loss",
    "href": "for_scientists.index.html#observables-with-loss",
    "title": "3  Wolframite for scientists",
    "section": "4.5 Observables with loss",
    "text": "4.5 Observables with loss\nThe above result is a perfectly reasonable, but simple, model. More realistically, we want to be able to understand mirrors that have losses, i.e. that don’t just reflect or transmit light, but that actually absorb or ‘waste’ light.\nThis is one of the places that Wolfram really shines. Almost the entire engine is designed around replacement rules. And so we just have to define a substitution, which says that reflection + transmission + loss is equal to 1:\n\n(def losses\n  [(w/-&gt; (w/** 'r1 2)\n         (w/+ 1\n              (w/- 'l1)\n              (w/- (w/** 't1 2))))\n   (w/-&gt; (w/** 'r2 2)\n         (w/+ 1\n              (w/- 'l2)\n              (w/- (w/** 't2 2))))])\n\nand substitute these into the equations. We’re going to go a step further however…",
    "crumbs": [
      "For Scientists",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Wolframite for scientists</span>"
    ]
  },
  {
    "objectID": "for_scientists.index.html#approximations",
    "href": "for_scientists.index.html#approximations",
    "title": "3  Wolframite for scientists",
    "section": "4.6 Approximations",
    "text": "4.6 Approximations\nRather than just substitute the new rule into our expressions, we’re going to take this opportunity to define some other replacement rules. Now so far, we’ve been fairly mathematically pure, but a lot of physics is about knowing when (and being able) to make good approximations.\n\n(def approximations\n  [(w/-&gt; (w/* 'r1 'r2)\n         (let [vars [(w/** 't1 2) (w/** 't2 2) 'l1 'l2]]\n           (-&gt;  (w/_&gt;&gt; (w/* (w/√ (w/** 'r1 2))\n                            (w/√ (w/** 'r2 2)))\n                       losses)\n                (w/Series ['t1 0 2]\n                          ['t2 0 2]\n                          ['l1 0 2]\n                          ['l2 0 2])\n                w/Normal\n                w/&lt;&lt;_&gt;&gt;\n                (w/_&gt;&gt; (mapv #(w/-&gt; % (w/* 'temp %)) vars))\n                (w/Series ['temp 0 1])\n                w/Normal\n                (w/_&gt;&gt; (w/-&gt; 'temp 1)))))])\n\n\\[\\left\\{\\text{r1} \\text{r2}\\to \\frac{1}{2} \\left(-\\text{l1}-\\text{l2}-\\text{t1}^2-\\text{t2}^2\\right)+1\\right\\}\\]\nWhat’s happening here is that we are simplifying the expression for r1*r2 by assuming that the transmission and loss for light going through a mirror is small. So small, that higher powers of these variabes are negligible. And so, we substitute the values into the expression, expand the functions in a power series and neglect any higher powers. The neglect is done by inserting ‘big O’ notation and then restricting the series to a single power in that variable. As we want to do this for multiple variables, then we map over each one. This is a complicated mathematical procedure, but Wolframite allows us to do this quite concisely, apart from some necessary Wolfram datatype conversions (e.g. using the w/Normal function).\nNote that Wolfram can also be used to define quite general approximations, using the ‘Pattern’ system. For example, let us assume that we want to expand Cos(x) as a polynomial when x is small. First, we need to know what the expansion is. We can find out by using Wolfram similarly to the above, i.e. \n\n(eval-&gt; (w/Series (w/Cos 'x)\n                  ['x 0 2])\n        w/Normal)\n\n\n(+ 1 (* -1/2 (Power x 2)))\n\nNow that we know (or have remembered!) the form, we can create a general rule that is not limited to specific symbol definitions.\n\n(def small-angle\n  (w/_&gt; (w/Cos (w/Pattern 'x (w/Blank)))\n        (w/+ 1 (w/* -1/2 (w/** 'x 2)))))\n\nThe rule can now be named and used for any Cos function with any argument:\n\n(eval-&gt; (w/_&gt;&gt; (w/Cos 'phi) small-angle))\n\n\n(ReplaceAll\n (Cos phi)\n (Replace (Cos (Pattern x (Blank))) (+ 1 (* -1/2 (Power x 2)))))\n\n\n(eval-&gt; (w/_&gt;&gt; (w/Cos (w/+ 1 'phi)) small-angle))\n\n\n(ReplaceAll\n (Cos (+ 1 phi))\n (Replace (Cos (Pattern x (Blank))) (+ 1 (* -1/2 (Power x 2)))))",
    "crumbs": [
      "For Scientists",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Wolframite for scientists</span>"
    ]
  },
  {
    "objectID": "for_scientists.index.html#independent-mirrors",
    "href": "for_scientists.index.html#independent-mirrors",
    "title": "3  Wolframite for scientists",
    "section": "4.7 Independent mirrors",
    "text": "4.7 Independent mirrors\nWith these approximations we can formulate our final expression for the optical intensity inside the cavity:\n\\[| \\text{E4}| ^2=\\left(\\frac{\\text{r2}^2 \\text{t1}^2}{\\cos (\\phi ) \\left(\\text{l1}+\\text{l2}+\\text{t1}^2+\\text{t2}^2\\right)+\\frac{1}{4} \\left(\\text{l1}+\\text{l2}+\\text{t1}^2+\\text{t2}^2-2\\right)^2-2 \\cos (\\phi )+1}\\text{/.}\\, \\left\\{\\text{r1}^2\\to -\\text{l1}-\\text{t1}^2+1,\\text{r2}^2\\to -\\text{l2}-\\text{t2}^2+1,\\text{Replace}\\left[\\cos (\\text{x$\\_$}),1-\\frac{x^2}{2}\\right]\\right\\}\\right)\\]\n\nsource: notebooks/for_scientists/index.clj",
    "crumbs": [
      "For Scientists",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Wolframite for scientists</span>"
    ]
  },
  {
    "objectID": "for_developers.index.html",
    "href": "for_developers.index.html",
    "title": "4  Wolframite for Clojure developers",
    "section": "",
    "text": "An explanation of Wolframite and why to use it, aimed at Clojure developers.\nTBD\n\nsource: notebooks/for_developers/index.clj",
    "crumbs": [
      "For Developers",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Wolframite for Clojure developers</span>"
    ]
  }
]