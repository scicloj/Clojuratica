[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Wolframite Documentation",
    "section": "",
    "text": "1 Wolframite\nAn interface between Clojure and the Wolfram Language (Supports Mathematica and Wolfram Engine ).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Wolframite</span>"
    ]
  },
  {
    "objectID": "index.html#status",
    "href": "index.html#status",
    "title": "Wolframite Documentation",
    "section": "1.1 Status",
    "text": "1.1 Status\nWolframite is currently (Q2/2024) under active development again. You can keep track of what is happening in this discussion.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Wolframite</span>"
    ]
  },
  {
    "objectID": "index.html#what-is-wolframite",
    "href": "index.html#what-is-wolframite",
    "title": "Wolframite Documentation",
    "section": "1.2 What is Wolframite?",
    "text": "1.2 What is Wolframite?\nWolframite (formerly Clojuratica) brings together two of today’s most exciting tools for high-performance, parallel computation.\nClojure is a dynamic functional programming language with a compelling approach to concurrency and state, a strong cast of persistent immutable data structures, and a growing reputation for doing all the right things. Wolfram Mathematica is arguably the world’s most powerful integrated tool for numerical computation, symbolic mathematics, optimization, and visualization and is build on top of its own splendid functional programming language, Wolfram Language.\nBy linking the two:\n\nWolframite lets you write and evaluate Wolfram/Mathematica code in Clojure with full syntactic integration. Now Clojure programs can take advantage of Wolfram’s enormous range of numerical and symbolic mathematics algorithms and fast matrix algebra routines.\nWolframite provides the seamless and transparent translation of native data structures between Clojure and Wolfram. This includes high-precision numbers, matricies, N-dimensional arrays, and evaluated and unevaluated Mathematica expressions and formulae.\nWolframite lets you write Wolfram as if it was Clojure by providing Clojure functions and vars for all Wolfram symbols, including docstrings and autocompletion in your favorite IDE\n[Tentative] Wolframite facilitates the “Clojurization” of Wolfram’s existing parallel-computing capabilities. Wolfram is not designed for threads or concurrency. It has excellent support for parallel computation, but parallel evaluations are initiated from a single-threaded master kernel which blocks until all parallel evaluations return. By contrast, Wolframite includes a concurrency framework that lets multiple Clojure threads execute Wolfram expressions without blocking others. Now it is easy to run a simulation in Clojure with 1,000 independent threads asynchronously evaluating processor-intensive expressions in Wolfram. The computations will be farmed out adaptively and transparently to however many Wolfram kernels are available on any number of processor cores, either locally or across a cluster, grid, or network.\n\nNotice that you cannot run more Wolfram kernels than your license allows (see wolframite/kernel-info!)\n\n\nWolframite is open-source and targeted at applications in scientific computing, computational economics, finance, and other fields that rely on the combination of parallelized simulation and high-performance number-crunching. Wolframite gives the programmer access to Clojure’s most cutting-edge features–easy concurrency and multithreading, immutable persistent data structures, and software transactional memory—alongside Wolfram’s easy-to-use algorithms for numerics, symbolic mathematics, optimization, statistics, visualization, and image-processing.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Wolframite</span>"
    ]
  },
  {
    "objectID": "index.html#usage",
    "href": "index.html#usage",
    "title": "Wolframite Documentation",
    "section": "1.3 Usage",
    "text": "1.3 Usage\n\n1.3.1 Prerequisites:\n\n1.3.1.1 Clojure\nFirst, if you haven’t already, install the Clojure CLI toolchain (homebrew is a great way to do this if you’re on Mac or Linux, but you can just as easily use the installation scripts if you prefer).\n\n\n1.3.1.2 Mathematica or Wolfram Engine\nNext, obviously, you’ll need to ensure that you have Wolfram Engine or Mathematica installed and your license (free for W. E.) registered - make sure you can run these tools on their own before trying Wolframite.\nFirst of all, you need to initialize a connection to a Wolfram/Mathematica kernel, like this:\n(wolframite.core/start)\nThis should also find and load the JLink JAR included with your installation. Watch stdout for an INFO log message (via clojure.tools.logging) like:\n\n=== Adding path to classpath: /Applications/Wolfram Engine.app/Contents/Resources/Wolfram Player.app/Contents/SystemFiles/Links/JLink/JLink.jar ===\n\nHowever, sometimes Wolframite may fail to find the correct path automatically and needs your help. You can set the WOLFRAM_INSTALL_PATH environment variable or Java system property (the latter takes priority) to point to the correct location. Example:\nexport WOLFRAM_INSTALL_PATH=/opt/mathematica/13.1\n\n\n\n1.3.2 Getting started\nStart a REPL with Wolframite on the classpath, then initialize it:\n(require '[wolframite.core :as wl] \n         '[wolframite.wolfram :as w]) ; Wolfram symbols as Clojure vars / fns\n;; Initialize\n(wl/start) ; =&gt; nil\n;; Use it:\n(wl/eval (w/Dot [1 2 3] [4 5 6]))\n;=&gt; 32\nMore examples\n(wl/eval (w/D (w/Power 'x 2) 'x))\n;=&gt; (* 2 x)\n(wl/eval (w/ChemicalData \"Ethanol\" \"MolarMass\"))\n;=&gt; (Quantity 46.069M (* \"Grams\" (Power \"Moles\" -1)))\n\n;; Accessing WlframAlpha\n(wl/eval (w/WolframAlpha \"How many licks does it take to get to the center of a Tootsie Pop?\")) ; BEWARE: must be online\n;=&gt; [(-&gt; [[\"Input\" 1] \"Plaintext\"] \"How many licks does it take to get to the Tootsie Roll center of a Tootsie Pop?\") (-&gt; [[\"Result\" 1] \"Plaintext\"] \"3481\\n(according to student researchers at the University of Cambridge)\")]\n\n(wl/eval (w/N w/Pi 20))\n;=&gt; 3.141592653589793238462643383279502884197169399375105820285M\n\n(wl/eval (w/Map (w/fn [x] (w/Sqrt x)) [4 16]))\n;=&gt; [2 4]\nTIP: Cursive - teach it to resolve w/fn as clojure.core/fn.\nNOTE: The wolframite.wolfram (w) ns has vars for all Wolfram symbols at the time of the last release. Check w/*wolfram-kernel-name* for kernel type/version and run (wolframite.impl.wolfram-syms.write-ns/write-ns!) to generate your own wolfram ns with whatever additional symbols your Wolfram/Mathematice has, and/or with custom “aliases”.\n\n1.3.2.1 Learning Wolframite\nRead through and play with explainer.clj and demo.clj, which demonstrate most of Wolframite’s features and what you can do with Wolfram.\n\n\n1.3.2.2 Customizing Wolframite\nA big advantage of Wolframite (as opposed to its earlier incarnations) is that we can now individually tailor the user experience at the level of initialization,\n(wl/start {:aliases '{** Power}})\n(wl/eval '(** 2 5)) ; =&gt; 32\n, and function call,\n(wl/start)\n(wl/eval '(** 2 5) {:aliases '{** Power}}) ; =&gt; 32\n. Use it how you want to!\nTIP: You can also get convenience vars for your aliases in wolframite.wolfram by running something like (wolframite.impl.wolfram-syms.write-ns/write-ns! &lt;path&gt; {:aliases '{** Power}}). After you load the file, you’ll be able to use (wl/eval (w/** 2 5) {:aliases '{** Power}}).\n\n\n\n1.3.3 Clerk Integration\nExample usage: (watching for changes in a folder)\nuser&gt; (require '[clojuratica.tools.clerk-helper :as ch])\nuser&gt; (ch/clerk-watch! [\"dev/notebook\"])\n\nOpen dev/notebook/demo.clj, make a change and save.\nOpen localhost:7777 in the browser\n\n\n\n1.3.4 How does it work?\nYou compose Wolfram expressions using the convenience functions and vars from wolframite.wolfram. These are then turned first into a symbolic representation of themselves and later into a tree of JLink Expr objects and sent to a Wolfram kernel subprocess (started by wl/start) for evaluation. The result is translated back from jlink.Expr into a Clojure form. This translation allows for some additional convenience logic, such as supporting w/* instead of Times.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Wolframite</span>"
    ]
  },
  {
    "objectID": "index.html#dependencies",
    "href": "index.html#dependencies",
    "title": "Wolframite Documentation",
    "section": "1.4 Dependencies",
    "text": "1.4 Dependencies\nWolframite requires Wolfram’s Java integration library JLink, which is currently only available with a Wolfram Engine or Mathematica installation. It will also need to know where the WolframKernel / MathKernel executable is, in order to be able to start the external evaluation kernel process. Normally, wl/start should be able to find these automatically, if you installed either into a standard location on Mac, Linux or Windows. However, if necessary, you can specify either with env variables / sys properties - see Prerequisites above.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Wolframite</span>"
    ]
  },
  {
    "objectID": "index.html#development",
    "href": "index.html#development",
    "title": "Wolframite Documentation",
    "section": "1.5 Development",
    "text": "1.5 Development\n\n1.5.1 Running tests\nTo run tests from the command line, you need to add JLink to the classpath (only REPL supports dynamically loading jars) - create a ./symlink-jlink.jar symlink and then run the tests:\nclojure -X:run-tests\n\n\n1.5.2 Deployment\nBuild the jar with clojure -T:build jar then deploy with env CLOJARS_USERNAME=&lt;tbd&gt; CLOJARS_PASSWORD=&lt;clojars-token&gt; clojure -T:build deploy\nNote: You need to log in to Clojars and generate a deployment token. You also need to be added to the SciCloj group there by an admin.\n\n1.5.2.1 Documentation\nDocumentation is written as literal programming sources in the notebooks directory and turned into HTML under docs using Clay and Quarto.\nTo render a single namespace/page, require Clay and run (clay/make! {:source-path \"&lt;path to the file&gt;\"\"}). Tip: You can also do this without quarto - just add :run-quarto false to the options.\nTo build the whole site, run clojure -T:build build-site (remembering to ensure that you have a ./symlink-jlink.jar symlink).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Wolframite</span>"
    ]
  },
  {
    "objectID": "index.html#authors",
    "href": "index.html#authors",
    "title": "Wolframite Documentation",
    "section": "1.6 Authors",
    "text": "1.6 Authors\nThe original Clojuratica was created by Garth Sheldon-Coulson, a graduate student at the Massachusetts Institute of Technology and Harvard Law School.\nOngoing maintenance and development over the years have been thanks to * Steve Chan, * Dan Farmer, * Norman Richards and others.\nMost recently, Clojuratica has been transformed into Wolframite by\n\nPawel Ceranka,\nThomas Clark and\nJakub Holý;\n\nand is now being maintained as part of the SciCloj project.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Wolframite</span>"
    ]
  },
  {
    "objectID": "index.html#contact",
    "href": "index.html#contact",
    "title": "Wolframite Documentation",
    "section": "1.7 Contact",
    "text": "1.7 Contact\nIf you would like to contact the maintainers or otherwise seek help from the community then please drop a message into our zulip channel or contact the team at SciCloj.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Wolframite</span>"
    ]
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "Wolframite Documentation",
    "section": "1.8 License",
    "text": "1.8 License\nDistributed under the Mozilla Public License either version 2.0 or (at your option) any later version.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Wolframite</span>"
    ]
  },
  {
    "objectID": "index.html#legal",
    "href": "index.html#legal",
    "title": "Wolframite Documentation",
    "section": "1.9 Legal",
    "text": "1.9 Legal\nThe product names used in this website are for identification purposes only. All trademarks and registered trademarks, including “Wolfram Mathematica,” are the property of their respective owners. Wolframite is not a product of Wolfram Research. The software on this site is provided “as-is,” without any express or implied warranty.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Wolframite</span>"
    ]
  },
  {
    "objectID": "index.html#further-documentation",
    "href": "index.html#further-documentation",
    "title": "Wolframite Documentation",
    "section": "1.10 Further documentation",
    "text": "1.10 Further documentation\nSee the book content menu on the left side\n\nsource: notebooks/index.clj",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Wolframite</span>"
    ]
  },
  {
    "objectID": "demo.html",
    "href": "demo.html",
    "title": "2  Quickstart",
    "section": "",
    "text": "2.1 Init\nFirst, we must initialize Wolframite and connect it to a Wolfram kernel, which will perform the computations.\nIf you get an error then please refer to the home README for further instructions. Your Wolfram installation is probably just in an unusual place and so you will have to provide the correct path.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Quickstart</span>"
    ]
  },
  {
    "objectID": "demo.html#init",
    "href": "demo.html#init",
    "title": "2  Quickstart",
    "section": "",
    "text": "(wl/start)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Quickstart</span>"
    ]
  },
  {
    "objectID": "demo.html#first-things-first",
    "href": "demo.html#first-things-first",
    "title": "2  Quickstart",
    "section": "2.2 First things first",
    "text": "2.2 First things first\nTo check that the kernel is working, try the following command:\n\n(wl/eval '(Dot [1 2 3] [4 5 6]))\n\n\n32\n\nAs you can see, we can treat Wolfram commands similarly to unevaluated Clojure source code, with some predictable syntax adaptations. This works fine as a starting point, but dealing with long chains of raw symbols doesn’t always scale well. Instead, you can also write\n\n(wl/eval (w/Dot [1 2 3] [4 5 6]))\n\n\n32\n\nor, using one of our fancy aliases,\n\n(wl/eval (w/&lt;*&gt; [1 2 3] [4 5 6]))\n\n\n32\n\n, which may be more familiar to the Mathematically inclined.\nHere, the ‘w’ namespace is a preconfigured, but configurable, intermediary to Wolfram’s built-in symbols. This allows you to manipulate Wolfram functions just like any other clojure symbol (and get reliable editor autocompletion).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Quickstart</span>"
    ]
  },
  {
    "objectID": "demo.html#code-strings",
    "href": "demo.html#code-strings",
    "title": "2  Quickstart",
    "section": "2.3 Code strings",
    "text": "2.3 Code strings\nThe above examples are the preferred ways to interop. You can however, use Wolfram command strings directly, e.g.\n\n(wl/eval \"{1 , 2, 3} . {4, 5, 6}\")\n\n\n32",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Quickstart</span>"
    ]
  },
  {
    "objectID": "demo.html#explicit-interning",
    "href": "demo.html#explicit-interning",
    "title": "2  Quickstart",
    "section": "2.4 Explicit interning",
    "text": "2.4 Explicit interning\nAlthough it shouldn’t normally be necessary, we can also intern Wolfram functions more directly i.e. to effectively define Wolfram functions as clojure functions.\nThe standard way of doing this is something like\n\n(def greetings\n  (wl/eval\n   (w/fn [x] (w/StringJoin \"Hello, \" x \"! This is a Mathematica function's output.\"))))\n\n\n(greetings \"Stephen\")\n\n\n\"Hello, Stephen! This is a Mathematica function's output.\"\n\nBut this can also be done at a lower level, e.g.\n\n(def W:Plus\n  (parse/parse-fn 'Plus {:jlink-instance (wolframite.impl.jlink-instance/get)}))\n\n\n(W:Plus 1 2 3)\n\n\n6",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Quickstart</span>"
    ]
  },
  {
    "objectID": "demo.html#bidirectional-translation-experimental",
    "href": "demo.html#bidirectional-translation-experimental",
    "title": "2  Quickstart",
    "section": "2.5 Bidirectional translation (experimental)",
    "text": "2.5 Bidirectional translation (experimental)\nCode translation in both directions is more difficult and is still somewhat experimental (especially in the wl-&gt;clj direction), but the basics work as expected, e.g.\n\n(wl/-&gt;clj \"GridGraph[{5, 5}]\")\n\n\n(GridGraph [5 5])\n\n\n(wl/-&gt;wl (w/GridGraph [5 5]) {:output-fn str})\n\n\n\"GridGraph[{5, 5}]\"",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Quickstart</span>"
    ]
  },
  {
    "objectID": "demo.html#graphics",
    "href": "demo.html#graphics",
    "title": "2  Quickstart",
    "section": "2.6 Graphics",
    "text": "2.6 Graphics\nThe above code however, within Mathematica, actually produces graphics. Does Wolframite support this?\nYes!\nGridGraph[{5, 5}]\nChemicalData[\"Ethanol\", \"StructureDiagram\"]\nTextStructure[\"The cat sat on the mat.\"]\nThe above graphics were created using the\n\nview\n\nfunction, as required above, and assumes that graphics are to be displayed in a browser.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Quickstart</span>"
    ]
  },
  {
    "objectID": "demo.html#computational-knowledge",
    "href": "demo.html#computational-knowledge",
    "title": "2  Quickstart",
    "section": "2.7 Computational knowledge",
    "text": "2.7 Computational knowledge\nWolfram is also known for its dynamic or ‘computational knowledge’ engine.\nThis can be accessed by many functions directly,\nGeoNearest[Entity[\"Ocean\"], Here]\n, or by posting a request to its online platform, Wolfram Alpha.\n\n(wl/eval (w/WolframAlpha \"number of moons of Saturn\" \"Result\"))\n\n\n(Quantity 145 (IndependentUnit \"moons\"))\n\nWolframAlpha[\"number of moons of Saturn\", \"Result\"]\nHere, we’ve shown a response with and without the view function, for reference.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Quickstart</span>"
    ]
  },
  {
    "objectID": "demo.html#mathematics-and-beyond",
    "href": "demo.html#mathematics-and-beyond",
    "title": "2  Quickstart",
    "section": "2.8 Mathematics and beyond",
    "text": "2.8 Mathematics and beyond\nIn a nutshell, this is how Wolframite is normally used, but, of course, this barely scratches the surface.\nIn particular, the flagship product of Wolfram, the one you’ve probably heard of, is Mathematica. And, as the name suggests, this entire system was built around the performance of abstract calculation and the manipulation of equations, e.g.\n\n(-&gt; (w/== 'E (w/* 'm (w/Power 'c 2)))\n\n    w/TeXForm\n    w/ToString\n    wl/eval\n    k/tex)\n\n\\[e=c^2 m\\]\noriginally answered the question ‘what is mass?’\n\n(-&gt; (w/== 'E (w/* 'm (w/Power 'c 2)))\n    (w/Solve 'm)\n    w/First w/First\n\n    w/TeXForm\n    w/ToString\n    wl/eval\n    k/tex)\n\n\\[m\\to \\frac{e}{c^2}\\]\nThis is where Wolfram, and so Wolframite, really shines. And if you’re interested in exploring this further, have a gander at one of our longer tutorials.\n\nsource: notebooks/demo.clj",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Quickstart</span>"
    ]
  },
  {
    "objectID": "gotcha.html",
    "href": "gotcha.html",
    "title": "3  Gotchas…",
    "section": "",
    "text": "(ns gotcha\n  [:require\n   [scicloj.kindly.v4.kind :as k]])\n\nAlthough we try to avoid such things, sometimes, when you’re fighting the host language, it’s just not practical to carry over the original conventions. Here we will try to keep an up-to-date list of possible surprises (that are not easy to ‘fix’).\n^ (Power) - Despite allowing a wider range of characters, we cannot use ^ in Wolframite because it is reserved for adding metadata to virtually all Clojure symbols. (^ x 2) will probably not do what you expect!\n:= (SetDelayed) - Is actually _= in Wolframite. This is because : is usually a reserved in Clojure for creating keywords. It’s worth noting though that this is possibly nicer, in a way, because _ looks like a placeholder, and defining a placeholder for the expression is what it does. It also sort of implies a delay…\n:&gt; (RuleDelayed) - Is _&gt; in Wolframite.\n. (Dot) - Has been changed to &lt;*&gt;, in the spirit of the inner product, because . is a key character in Clojure, and most object-oriented systems, for namespacing.\n/. (ReplaceAll) - Similarly, has been changed to x&gt;&gt; (and Replace to x&gt;) for consistency.\n=. (Unset) - has also been changed to =!; be careful not to confuse this with !=!\nSymbols within threading macros. - After spending so much time playing with symbols, be careful of slipping into things like (-&gt; 'x '(Power 1)) This will not work because threads are macros and so combining them with unevaluated functions will lead to errors.\nSymbols passed to Wolfram must be alphanumeric - In the end, when they get passed to the Wolfram kernel, symbols must be strictly alphanumeric (apart from forward slashes and dollar signs), i.e. r_2 is currently not allowed. This is due to underlying limitations of the Wolfram language. Much like with Mathematica however, we can get around this is general by using Wolframite’s aliasing system (see the relevant tutorials).\nVectors, [], vs lists, (). - Lists are used to represent functions and so when combining Clojure and Wolfram expressions, make sure that data literals are vectors. For example, (wh/view (w/ListLinePlot (range 10))) will fail (otherwise unexpectedly), but (wh/view (w/ListLinePlot (into [] (range 10)))) will give you what you expect.\n\nsource: notebooks/gotcha.clj",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Gotchas...</span>"
    ]
  },
  {
    "objectID": "packages.html",
    "href": "packages.html",
    "title": "4  Packages",
    "section": "",
    "text": "(ns packages\n  \"A notebook demonstrating how to import and use Wolfram packages in Wolframite.\"\n  (:require\n   [scicloj.kindly.v4.kind :as k]\n   [wolframite.core :as wl]\n   [wolframite.wolfram :as w]))\n\nWorking with packages has never been easier! Following the Wolfram symbol convention, we introduce Wolframite’s version of &lt;&lt;, a.k.a. Get, to both load the given file (*.wl or *.m) into the working kernel and to attach the Wolfram context’s symbols (including functions) to a Clojure namespace. This either uses the context’s name or the characters provided as a Clojure symbol.\nThe functions inside the Wolfram package can then be used just like any other Wolfram functions.\nFor example, try loading WolframPackageDemo.wl and running the two functions defined inside:\n  tryIt[x_] :=\n    Module[{y},\n      x^3\n    ]\nand\nadditional[y_]:=3*y\n.\n\n(wl/restart)\n\n\n(wl/&lt;&lt;! \"resources/WolframPackageDemo.wl\")\n\n\n(wl/eval\n (WolframPackageDemo/tryIt 10))\n\n\n1000\n\n\n(wl/eval\n (WolframPackageDemo/additional 10))\n\n\n30\n\n\n(wl/eval\n (w/Information WolframPackageDemo/tryIt \"Usage\"))\n\n\n\"Used for testing Wolframite.\"\n\nThat’s it! As you can see, the functions are callable and the documentation is available too.\nIf you want to change the context name, e.g. to make it shorter, then this is also simple. In general, we allow for the package name and context name to be different, so the full call is (... path.wl context alias), i.e.\n\n(wl/&lt;&lt;! \"resources/WolframPackageDemo.wl\" \"WolframPackageDemo\" 'pck)\n\n\n(wl/eval (pck/tryIt 10))\n\n\n1000\n\n\n(wl/eval  (w/Information pck/additional \"Usage\"))\n\n\n\"Another function in the test package.\"\n\nAnd so, you have the whole power of Wolfram packages at your fingertips. And to be honest, this is actually easier to work with than using Wolfram’s contexts directly. Clojure does namespaces well.\n\nsource: notebooks/packages.clj",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Packages</span>"
    ]
  },
  {
    "objectID": "for_scientists.index.html",
    "href": "for_scientists.index.html",
    "title": "5  Wolframite for scientists I (Introduction)",
    "section": "",
    "text": "5.1 Abstract\nWe introduce you, the motivated scientist (likely the mathematical sort), to using the Wolfram programming language as a Clojure library. Following some brief inspiration (why on earth should you do this?), and getting started notes, we then outline a ‘real’ workflow using the example of optical cavities.",
    "crumbs": [
      "Tutorials for scientists",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Wolframite for scientists I (Introduction)</span>"
    ]
  },
  {
    "objectID": "for_scientists.index.html#motivation---why-on-earth",
    "href": "for_scientists.index.html#motivation---why-on-earth",
    "title": "5  Wolframite for scientists I (Introduction)",
    "section": "5.2 Motivation - Why on earth?",
    "text": "5.2 Motivation - Why on earth?\nThe Wolfram programming language is ‘best-in-class’ for certain specialist tasks, like manipulating equations, but, as Randall Munroe might have said, &gt; Wolfram combines the flexibility and power of abstract mathematics with the intuitive clarity of abstract mathematics.\nClojure, on the other-hand, is a first-class, general-purpose, programming language whose core namespace and dynamical, functional, paradigm is well suited to data exploration and manipulation. So why don’t we call Wolfram from Clojure? It seems like the atypical ‘best of both worlds’.",
    "crumbs": [
      "Tutorials for scientists",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Wolframite for scientists I (Introduction)</span>"
    ]
  },
  {
    "objectID": "for_scientists.index.html#getting-started-for-scientists",
    "href": "for_scientists.index.html#getting-started-for-scientists",
    "title": "5  Wolframite for scientists I (Introduction)",
    "section": "5.3 Getting Started (for scientists)",
    "text": "5.3 Getting Started (for scientists)\nThis tutorial aims to be as comprehensive a reference as possible for the average scientist and, as such, is not concise (and will probably only get longer). For a quick-fire introduction, see the ‘demo’ page. If the demo is too short and this is too long however, you can always run a ‘search’ on the text for the relevant examples. We won’t judge you!\n\n5.3.1 Clojure\nThere are many useful online tools for getting started with Clojure. For an overview of the language itself, have a look at Eric Normand’s materials. If you’d like to jump straight-in with interactive examples then try the koans.\n\n5.3.1.1 Clojure physics\nIf you’d like to see why a physicist might be interested in Clojure then have a look at the video below.\n\n\n\n5.3.1.2 Clojure notation\nFor those who are still fairly new to clojure, the first thing to get used to is the style of notation. It might seem strange at first, but a functional LisP can be more efficient (symbolically) than a lot of object-oriented languages and even standard mathematical notation. For example, why write 1+1+1+2 and not (+ 1 1 1 2)? They have around the same number of characters and yet even here it’s arguable that the signal to noise ratio is higher for the second one. Where the second form really shines however, is in it’s scalability. As soon as you add another operator, e.g. 1+1+1+2/3, we have a problem. Okay so you made it through primary school and know that 1+1+1+2/3 is really 1+1+1+(2/3) and not (1+1+1+2)/3, but the mental complexity is still there, you’re just used to it. If we introduce another operator, e.g. 1+1+1+2✝3, now what do you do? The truth is that if we stick to one simple rule, i.e. use brackets, then we completely solve a whole range of problems in advance, with the ‘cost’ of having to write two characters. In fact, although it might not be obvious, the Wolfram language is actually inspired by/built on the LisP syntax (underneath). The outer layer is just to make it look more like the inefficient notation that mathematicians already know and love…\nIn summary, BODMAS is six rules and incomplete. (function argument …) is a single rule and complete. Be kind to yourself, just write (+ 1 1 1 (/ 2 3)) :).\nIf you’re still unconvinced about the benefits of a simple syntax then remember that LisP is a programmable programming language: and its the syntax that delivers macros.\n\n\n\n5.3.2 Data science\nIf you’re sold on Clojure and interested in problems close to data science then an overview of some of the key analysis libraries can be found here.\n\nIf you’re really ready to use Wolfram though, then read on!",
    "crumbs": [
      "Tutorials for scientists",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Wolframite for scientists I (Introduction)</span>"
    ]
  },
  {
    "objectID": "for_scientists.index.html#wolfram-basics",
    "href": "for_scientists.index.html#wolfram-basics",
    "title": "5  Wolframite for scientists I (Introduction)",
    "section": "5.4 Wolfram basics",
    "text": "5.4 Wolfram basics\n\n5.4.1 Let’s define our terms!\nOne of the really nice things about using Wolfram as a library is that our middle man (Wolframite) can provide default substitutions to simplify verbose terms, e.g. ‘(Power x 2) can become’(** x 2) or even ’(**2 x), for readability. What’s even nicer however, is that we can make our own aliases at runtime: the choice is ours!\nWe mention this now because the best time to define our terms is before we start. The first few aliases give us an insight into how I would have designed Wolfram. The last two go a step further. Here, we make use of Clojure’s modernity and decision to support a much wider character set than Wolfram. Depending on your editor, it can be just as easy to enter these unicode characters as typing the long function name, but the real win is in the readability. Remember, we read our documents far more often than we write them (even if it’s just peer review…).\nTherefore, we enter the following.\n\n(def aliases\n  '{** Power\n    ++ Conjugate\n\n    x&gt; Replace\n    x&gt;&gt; ReplaceAll\n    &lt;_&gt; Expand\n    &lt;&lt;_&gt;&gt; ExpandAll\n    ++&lt;_&gt; ComplexExpand\n    &gt;_&lt; Simplify\n    &gt;&gt;_&lt;&lt; FullSimplify\n\n    ⮾ NonCommutativeMultiply\n    √ Sqrt\n    ∫ Integrate})\n\n\n(wl/restart {:aliases aliases})\n\nWe can define new aliases by simply using the core clojure functions/macros. This works fine, but these are only symbol replacements and so we can’t benefit from using these entities in macros or from editor autocompletion. For the best experience therefore, we recommend using ‘write-ns!’.\n\n(comment\n  (write/write-ns! \"src/wolframite/wolfram.clj\"\n                   {:aliases aliases}))\n\nUsing this command, we can generate a full namespace at the given location and so refer to the new symbol aliases more directly. The command appears here in a comment block to avoid unnecessary recomputation. See the ‘Literate programming’ section for an explanation.\n\n\n5.4.2 Access to knowledge\nWith the recent emergence of ChatGPT and similar AI systems, direct access to knowledge from free-form linguistic input is in demand. Wolfram was an early pioneer of this, launching its product, Wolfram|Alpha, in 2009. Wolfram occupies a different space however, focusing mainly on what it describes as ‘computational knowledge’. Rather than strictly using an LLM, it combines its knowledge databases with the ability to perform Wolfram operations on the retrieved data, before returning the result.\nFor example, we can make both knowledge-based requests and perform complicated calculations on demand (requires internet access).\nWolframAlpha[\"What is the mass of 5 rubidium atoms?\", \"Result\"]\nWolframAlpha[\"What is the relativistic momentum of a 0.8c electron?\", \"Result\"]\nIn each case, Wolfram does not just provide the answer, but returns the data in different formats and units in an attempt to anticipate different usecases. This verbosity might seem frustrating, but of course adds flexibility: leaving the user free to filter or present the results in any way that they wish. Here, we have used the last argument to simply display the core ‘Result’.\n\n\n5.4.3 Defining expressions\nRather than just querying the Wolfram servers however, the vast majority of people who use this library will want to write their own programs.\nFor those coming from Mathematica (the official, graphical front-end for the Wolfram language), a good place to start is defining expressions.\nThis is where the main cost of ‘Wolfram as a library’ lies. In a Wolfram environment, all non-language characters are treated as global symbols by default. This works well for symbol and expression manipulation (Mathematica’s assumed raison d’être), but not for any other purpose. To successfully embed Wolfram expressions into a general purpose programming language we must make choices.\nIn this library, there are two approaches. For all official functions, the cleanest way of referring to them is to import the base symbol namespace, i.e. wolframite.wolfram, or a customized one, e.g. ‘wolframite.wolfram-extended’. This allows the user to manipulate expressions like other clojure functions (and to access the associated Wolfram documentation from your editor) e.g.\n\n(-&gt; 2\n    (w/Power 1)\n    (w/Subtract 2))\n\n\n(Subtract (Power 2 1) 2)\n\nTo calculate/retrieve the result we then simply add ‘eval’ from the Wolframite core namespace:\n\n(-&gt; 2\n    (w/Power 1)\n    (w/Subtract 2)\n    wl/eval)\n\n\n0\n\nNote, separating expression chains from automatic eval was done for efficiency. Previously, all Wolfram expressions were individually evaluated with separate kernel calls and this was considered a performance problem.\nTo deal with general symbols, we return to one of LisPs’ strengths: controlled evaluation. Historically necessitated by LisPs’ ‘code-as-data’ paradigm, all LisPs can deal with general symbols by simply not evaluating them. This makes it easy to create and manipulate arbitrary Wolfram expressions, as we can simply treat them as unevaluated symbols (note our use of the new aliases too).\n\n(-&gt; 'x\n    (w/** 1)\n    (w/- '5)\n    wl/eval)\n\n\n(+ -5 x)\n\nThis comes at the cost of having to ‘mark’ symbols, lists and functions manually, but it’s a choice between being unevaluated by default (e.g. Wolfram, Maple), unevaluated when marked (LisPs) or no easy way to work with symbols (the vast majority of programming languages). It also comes at the cost of some ‘gotchas’ (listed elsewhere in the docs), but these are avoided for the most part by using a wolframite.wolfram namespace (and ‘write-ns!’ function), as introduced in the beginning.\n\n\n5.4.4 Defining functions\nFunctions are slightly more complicated. Functions can be defined in many different ways. The easiest way is to keep functions, where appropriate, as standard Clojure expressions.\nIf you’re used to using Wolfram/Mathematica, then f[x_]:=x^2 is simply\n\n(defn f [x] (wl/eval (w/Power x 2)))\n\n\n(f 2)\n\n\n4\n\n\n(f 'x)\n\n\n(Power x 2)\n\n. If instead you want to define functions inside the Wolfram kernel, and attach them to arbitrary symbols, then the most ergonomic way is\n\n(wl/eval (w/_= 'f (w/fn [x] (w/** x 2))))\n\n\n(wl/eval '(f 5))\n\n\n25\n\n, where ’_=’ is the Wolframite version of ‘:=’ (SetDelayed). See the ‘Gotchas’ section for why. Rather than a direct alias, w/fn is a special form that allows you to define Wolfram functions in a convenient way. Note that ‘f’ is a new symbol and therefore cannot be expected to be part of wolframite.wolfram or similar namespaces. Therefore, we must call the function using an unevaluated Clojure list.\nIn my opinion, this mixes the best of Wolfram and Clojure: and scales well. The most explicitly Wolfram way of doing it however, is to write\n\n(wl/eval (w/Clear 'f))\n\n\n(wl/eval '(_= (f (Pattern x (Blank))) (Power x 2)))\n\n\n(wl/eval '(f 5))\n\n\n25\n\n, where we first removed all definitions from ‘f’ before reassigning the function.\nOnce you can define your own aliases and create arbitrary expressions and functions, then you’re basically good to go.",
    "crumbs": [
      "Tutorials for scientists",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Wolframite for scientists I (Introduction)</span>"
    ]
  },
  {
    "objectID": "for_scientists.index.html#mixing-functions",
    "href": "for_scientists.index.html#mixing-functions",
    "title": "5  Wolframite for scientists I (Introduction)",
    "section": "5.5 Mixing functions",
    "text": "5.5 Mixing functions\nWolframite is not just a different way to typeset Wolfram functions. Indeed, there would be very little point in building an entire library around this. Instead, Wolframite wants to help the user bring Wolfram’s functions into a general Clojure workflow, i.e. to mix Clojure and Wolfram together, such that there is another, potentially better way, to do science.\nSuch is the case, we can demonstrate a new workflow. As noted above, it is straightforward to define functions in Wolframite, as in Wolfram/Mathematica.\n\n(defn ||2\n  \"The intensity: the value times the conjugate of the value or, equivalently, the absolute value squared.\"\n  [x]\n  (w/* x (w/++ x)))\n\n\n(-&gt; (w/* 3 w/I)\n    (w/+ 5)\n    ||2\n    wl/eval)\n\n\n34\n\nHere we make a shorthand, the absolute value squared. Defined as a clojure function, it simply abstracts two Wolfram operations, which can then be used alongside others.\nAnd yet there are there are two meaningful improvements already. First of all, we can, currently, use more mathematical characters in Clojure, such that even the raw code can approach familiar symbolic maths. Second of all, we can exploit Clojure’s ‘threading’ features. In my view, chaining Wolfram function calls together with threading macros is actually a big usability improvement. Wolfram expressions can get pretty involved (it’s common to end up with expressions that hold 10s of symbols and operators and 100s are not unheard of) and trying to read these from the inside out is just not natural for the average human. It stands to reason then that chaining functions together (and debugging them!) can really be a pain. In fact, Wolfram recognised this problem when it introduced the prefix operator, ‘@’, to help with function composition, e.g. f@g@h. Unfortunately however, this doesn’t work with multiple arguments. It is possible to do things like f@@args, and even things like f@@@{{a, b}, {c, d}}, but the readability quickly becomes dire. On the other hand, Clojure’s threading is simple, clear and scalable.\nIn fact, a little Clojure goes a long way. Look how easily we can add substantial UX conveniences to our workflow.\n\n(defmacro eval-&gt;\n  \"Extends the threading macro to automatically pass the result to wolframite eval.\"\n  [& xs]\n  `(-&gt; ~@xs wl/eval))\n\n\n(defn TeX\n  \"UX fix. Passes the Wolfram expression to ToString[TeXForm[...]], as the unsuspecting coder might not realise that 'ToString' is necessary.\"\n  [tex-form]\n  (w/ToString (w/TeXForm tex-form)))\n\n\n(defmacro TeX-&gt;\n  \"Extends the thread-first macro to automatically eval and prepare the expression for TeX display.\"\n  [& xs]\n  `(-&gt; ~@xs TeX wl/eval k/tex))\n\nNow we can implicitly chain operations together, evaluate the result and get a nice TeX display in the browser.\n\n(TeX-&gt; (w/* 'x w/I)\n       (w/+ 'y)\n       ||2)\n\n\\[(y+i x) \\left(y^*-i x^*\\right)\\]\nIt’s just a small example, but LisP is designed for metaprogramming and so the sky’s the limit when it comes to building more features around Wolfram functions. A sceptical reader may point out that eval and display are solved problems within the Mathematica system, but in my opinion there are solid reasons for not wanting to be confined to a specific IDE. Have a look at ‘Why literate programming?’ in the FAQs for more details.\nBefore we finish this part of the tutorial, let’s consider a (slightly) more realistic example.\nWolfram can be used to define quite general approximations, using the ‘Pattern’ system. For example, let us assume that we want to expand Cos(x) as a polynomial when x is small. First, we need to know what the expansion is. We can actually find out by using Wolfram! i.e. \n\n(eval-&gt; (w/Series (w/Cos 'x)\n                  ['x 0 2])\n        w/Normal)\n\n\n(+ 1 (* -1/2 (Power x 2)))\n\nNow that we know (or have remembered!) the form, we can create a general rule that is not limited to specific symbol definitions:\n\n(def small-angle\n  (w/_&gt; (w/Cos (w/Pattern 'x (w/Blank)))\n        (w/+ 1 (w/* -1/2 (w/** 'x 2)))))\n\n, where we have made use of Clojure’s native support for ratios. The rule can now be named and used for any Cos function with any argument. Which of course looks much nicer using TeX.\n\n(TeX-&gt; (w/x&gt;&gt; (w/Cos 'phi)\n              small-angle))\n\n\\[1-\\frac{\\phi ^2}{2}\\]\n\n(TeX-&gt; (w/x&gt;&gt; (w/Cos (w/+ 1 'phi))\n              small-angle))\n\n\\[1-\\frac{1}{2} (\\phi +1)^2\\]",
    "crumbs": [
      "Tutorials for scientists",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Wolframite for scientists I (Introduction)</span>"
    ]
  },
  {
    "objectID": "for_scientists.cavity_physics.html",
    "href": "for_scientists.cavity_physics.html",
    "title": "6  Wolframite for scientists II (Cavity physics)",
    "section": "",
    "text": "6.1 Cavities?\nOutside of the operating room, the most common notion of cavities is, what we might otherwise call, an optical resonator. One way of looking at it, although quantum mechanics makes this more difficult, is that an optical cavity is simply just a light trap, such that once light gets in, it bounces around for a while and then leaves.\nFor demo purposes, our question then is ‘how can we model this?’ and ‘how does the light intensity, inside the cavity, depend on some experimental variables’?",
    "crumbs": [
      "Tutorials for scientists",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Wolframite for scientists II (Cavity physics)</span>"
    ]
  },
  {
    "objectID": "for_scientists.cavity_physics.html#setup",
    "href": "for_scientists.cavity_physics.html#setup",
    "title": "6  Wolframite for scientists II (Cavity physics)",
    "section": "6.2 Setup",
    "text": "6.2 Setup\nAssuming a simple two-mirror setup, with independent reflectivities and transmission, the system can be described as a ray oscillating between four key interfaces, as illustrated in the figure.\n\nWe must therefore consider the electric field at each interface, before solving for the intensity both inside and outside.",
    "crumbs": [
      "Tutorials for scientists",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Wolframite for scientists II (Cavity physics)</span>"
    ]
  },
  {
    "objectID": "for_scientists.cavity_physics.html#interfaces",
    "href": "for_scientists.cavity_physics.html#interfaces",
    "title": "6  Wolframite for scientists II (Cavity physics)",
    "section": "6.3 Interfaces",
    "text": "6.3 Interfaces\nSetting the incoming field amplitude to unity, then the value of the field at position one, after one round trip, is the sum of the transmission coefficient and the field travelling in the opposing direction e.g.\n\n(def E1\n  (w/+ 't1 (w/* 'r1 (w/- 'E4))))\n\nAt position two, the same field has travelled the full length of the cavity, L, and so has picked up a change in phase,\n\n(def phi\n  (w/* 'k 'L))\n\n, where k is the field wavenumber:\n\n(def E2\n  (w/* E1 (w/Exp (w/* w/I phi))))\n\n. Note how we are able to seamlessly mix Clojure and Wolfram expressions.\nAt position three, the field undergoes reflection and so now carries an additional reflection coefficient as well as an extra π phase change.\n\n(def E3\n  (w/* (w/- 'r2) E2))\n\nBy position four, the field has travelled a further distance L and so is now equal to\n\n(def E4\n  (w/* E3 (w/Exp (w/* w/I phi))))\n\n. Which we can evaluate and visualise with one of our handy macros.\n\n(TeX-&gt;&gt; E4\n        (w/== 'E4))\n\n\\[\\text{E4}=\\text{r2} \\left(-e^{2 i k L}\\right) (\\text{t1}-\\text{E4} \\text{r1})\\]\n## Fields Using these expressions, we can now calculate the inner, transmitted and reflected fields of the cavity (with some subtle phase assumptions). Note how easy it is to, first of all, form an equation from the symbol ’E4 and the clojure variable E4, and, second of all, to rearrange the equation for a solution.\n\n(def e4 (-&gt; (w/== 'E4 E4)\n            (w/Solve 'E4)\n            w/First w/First))\n\n\n(TeX-&gt; e4)\n\n\\[\\text{E4}\\to \\frac{\\text{r2} \\text{t1} e^{2 i k L}}{-1+\\text{r1} \\text{r2} e^{2 i k L}}\\]\nSubstitution and simplification can then be used to arrive at the transmission and reflection, respectively.\n\n(def T (-&gt; (w/x&gt;&gt; (w/* E2 't2)\n                  e4)\n           w/&gt;&gt;_&lt;&lt;))\n\n\n(TeX-&gt;&gt; T (w/== 'T))\n\n\\[T=\\frac{\\text{t1} \\text{t2} e^{i k L}}{1-\\text{r1} \\text{r2} e^{2 i k L}}\\]\n\n(def R (-&gt; (w/+ (w/* E4 't1) 'r1)\n           (w/x&gt;&gt; e4)\n           w/&gt;&gt;_&lt;&lt;\n           w/Together))\n\n\n(TeX-&gt;&gt; R (w/== 'R))\n\n\\[R=\\frac{\\text{r1}^2 \\text{r2} e^{2 i k L}+\\text{r2} \\text{t1}^2 e^{2 i k L}-\\text{r1}}{-1+\\text{r1} \\text{r2} e^{2 i k L}}\\]",
    "crumbs": [
      "Tutorials for scientists",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Wolframite for scientists II (Cavity physics)</span>"
    ]
  },
  {
    "objectID": "for_scientists.cavity_physics.html#observables",
    "href": "for_scientists.cavity_physics.html#observables",
    "title": "6  Wolframite for scientists II (Cavity physics)",
    "section": "6.4 Observables",
    "text": "6.4 Observables\nTaking the square of the fields (using the complex conjugate), gives the corresponding observables, i.e. things that can be actually measured.\n\n(def I4 (-&gt; (w/x&gt;&gt; 'E4 e4) ||2\n            w/++&lt;_&gt;\n            w/&gt;&gt;_&lt;&lt;))\n\n\n(TeX-&gt; (w/== 'I4 (w/** (w/Abs 'E4) 2) I4))\n\n\\[\\text{I4}=| \\text{E4}| ^2=\\frac{\\text{r2}^2 \\text{t1}^2}{-2 \\text{r1} \\text{r2} \\cos (2 k L)+\\text{r1}^2 \\text{r2}^2+1}\\]\n\n(def Tsq (-&gt; T ||2\n             w/++&lt;_&gt;\n             w/&gt;&gt;_&lt;&lt;))\n\n\n(TeX-&gt; (w/== (w/** 'T 2) Tsq))\n\n\\[T^2=\\frac{\\text{t1}^2 \\text{t2}^2}{-2 \\text{r1} \\text{r2} \\cos (2 k L)+\\text{r1}^2 \\text{r2}^2+1}\\]\n\n(def Rsq (-&gt; R ||2\n             w/++&lt;_&gt;\n             w/&gt;&gt;_&lt;&lt;\n             w/Together))\n\n\n(TeX-&gt; (w/== (w/** 'R 2) Rsq))\n\n\\[R^2=\\frac{-2 \\text{r1}^3 \\text{r2} \\cos (2 k L)-2 \\text{r1} \\text{r2} \\text{t1}^2 \\cos (2 k L)+\\text{r1}^4 \\text{r2}^2+2 \\text{r1}^2 \\text{r2}^2 \\text{t1}^2+\\text{r1}^2+\\text{r2}^2 \\text{t1}^4}{-2 \\text{r1} \\text{r2} \\cos (2 k L)+\\text{r1}^2 \\text{r2}^2+1}\\]",
    "crumbs": [
      "Tutorials for scientists",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Wolframite for scientists II (Cavity physics)</span>"
    ]
  },
  {
    "objectID": "for_scientists.cavity_physics.html#observables-with-loss",
    "href": "for_scientists.cavity_physics.html#observables-with-loss",
    "title": "6  Wolframite for scientists II (Cavity physics)",
    "section": "6.5 Observables with loss",
    "text": "6.5 Observables with loss\nThe above result is a perfectly reasonable, but simple, model. More realistically, we want to be able to understand mirrors that have losses, i.e. that don’t just reflect or transmit light, but that actually absorb or ‘waste’ light.\nThis is one of the places that Wolfram really shines. Almost the entire engine is designed around replacement rules. And so we just have to define a substitution, which says that reflection + transmission + loss is equal to 1:\n\n(def losses\n  [(w/-&gt; (w/** 'r1 2)\n         (w/+ 1\n              (w/- 'l1)\n              (w/- (w/** 't1 2))))\n   (w/-&gt; (w/** 'r2 2)\n         (w/+ 1\n              (w/- 'l2)\n              (w/- (w/** 't2 2))))])\n\nand substitute these into the equations. We’re going to go a step further however…",
    "crumbs": [
      "Tutorials for scientists",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Wolframite for scientists II (Cavity physics)</span>"
    ]
  },
  {
    "objectID": "for_scientists.cavity_physics.html#approximations",
    "href": "for_scientists.cavity_physics.html#approximations",
    "title": "6  Wolframite for scientists II (Cavity physics)",
    "section": "6.6 Approximations",
    "text": "6.6 Approximations\nRather than just substitute the new rule into our expressions, we’re going to take this opportunity to define some other replacement rules. Now so far, we’ve been fairly mathematically pure, but a lot of physics is about knowing when (and being able) to make good approximations.\n\n(def approximations\n  [(w/-&gt; (w/* 'r1 'r2)\n         (let [vars [(w/** 't1 2) (w/** 't2 2) 'l1 'l2]]\n           (-&gt;  (w/x&gt;&gt; (w/* (w/√ (w/** 'r1 2))\n                            (w/√ (w/** 'r2 2)))\n                       losses)\n                (w/Series ['t1 0 2]\n                          ['t2 0 2]\n                          ['l1 0 2]\n                          ['l2 0 2])\n                w/Normal\n                w/&lt;&lt;_&gt;&gt;\n                (w/x&gt;&gt; (mapv #(w/-&gt; % (w/* 'temp %)) vars))\n                (w/Series ['temp 0 1])\n                w/Normal\n                (w/x&gt;&gt; (w/-&gt; 'temp 1)))))])\n\n\n(TeX-&gt; approximations)\n\n\\[\\left\\{\\text{r1} \\text{r2}\\to \\frac{1}{2} \\left(-\\text{l1}-\\text{l2}-\\text{t1}^2-\\text{t2}^2\\right)+1\\right\\}\\]\nWhat’s happening here is that we are simplifying the expression for r1r2 by assuming that the transmission and loss for light going through a mirror is small. So small, that higher powers of these variabes are negligible. And so, we substitute the values into the expression, expand the functions in a power series and neglect any higher powers. The neglect is done by inserting ‘big O’ notation and then restricting the series to a single power in that variable. As we want to do this for multiple variables, then we map over each one. This is a complicated mathematical procedure, but Wolframite allows us to do this quite concisely, apart from some necessary Wolfram datatype conversions (e.g.* using the w/Normal function).",
    "crumbs": [
      "Tutorials for scientists",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Wolframite for scientists II (Cavity physics)</span>"
    ]
  },
  {
    "objectID": "for_scientists.cavity_physics.html#the-cavity-field",
    "href": "for_scientists.cavity_physics.html#the-cavity-field",
    "title": "6  Wolframite for scientists II (Cavity physics)",
    "section": "6.7 The cavity field",
    "text": "6.7 The cavity field\nWe remember (from part I) that Wolfram can define quite general approximations. With the small angle approximation, and those defined above, we can formulate our final expression for the optical intensity inside the cavity:\n\n(def small-angle\n  (w/_&gt; (w/Cos (w/Pattern 'x (w/Blank)))\n        (w/+ 1 (w/* -1/2 (w/** 'x 2)))))\n\n\n(def I4--approx\n  (eval-&gt; I4\n          (w/x&gt;&gt; (w/-&gt; (w/Cos (w/* 2 'k 'L))\n                       (w/Cos 'phi)))\n          (w/x&gt;&gt; approximations)\n          (w/x&gt;&gt; (w/-&gt; (w/** (w/* 'r1 'r2) 2)\n                       (-&gt; (w/x&gt;&gt; (w/* 'r1 'r2) approximations)\n                           (w/** 2))))\n          (w/x&gt;&gt; (conj losses small-angle))\n          w/&gt;_&lt;))\n\n\n(TeX-&gt;&gt; I4--approx\n        (w/== (w/** (w/Abs 'E4) 2)))\n\n\\[| \\text{E4}| ^2=\\frac{4 \\text{t1}^2 \\left(-\\text{l2}-\\text{t2}^2+1\\right)}{-2 \\left(\\phi ^2-2\\right) \\left(\\text{l1}+\\text{l2}+\\text{t1}^2+\\text{t2}^2-2\\right)+\\left(\\text{l1}+\\text{l2}+\\text{t1}^2+\\text{t2}^2-2\\right)^2+4}\\]",
    "crumbs": [
      "Tutorials for scientists",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Wolframite for scientists II (Cavity physics)</span>"
    ]
  },
  {
    "objectID": "for_scientists.cavity_physics.html#visualised",
    "href": "for_scientists.cavity_physics.html#visualised",
    "title": "6  Wolframite for scientists II (Cavity physics)",
    "section": "6.8 Visualised",
    "text": "6.8 Visualised\nSo we finally have an equation for the field inside the cavity. If we were mathematicians, then of course, we might have stopped here. Assuming that it’s only real scientists who’re reading this (shhh!), then the next step is to explore these equations graphically, under practical assumptions.\nFor this, we will define a few utility functions, that also demonstrate Wolfram’s conciseness.\n\n(defn linspace\n  \"A list of n numbers between a and b.\"\n  [a b n]\n  (let [d (/ (- b a) (dec n))]\n    (into []\n          (map (fn [x]\n                 (+ a\n                    (* x d)))\n               (range n)))))\n\n\n(defn coordinates\n  \"There's no numpy here, so what do we do? It turns out Wolfram can reimplement a meshgrid-like function very concisely (let's not talk about the performance though...).\"\n  [xmin xmax ymin ymax]\n  (eval-&gt; (w/Outer w/List\n                   (linspace xmin xmax 100)\n                   (linspace ymin ymax 100))\n          (w/Flatten 1)))\n\n\n(defn Efield\n  \"For convenience, we build a clojure function over the Wolfram expression created earlier.\"\n  [t1 t2 l1 l2 phi]\n  (wl/eval (w/Clear 'f))\n  (wl/eval `(_= (f (Pattern t1 (Blank))\n                   (Pattern t2 (Blank))\n                   (Pattern l1 (Blank))\n                   (Pattern l2 (Blank))\n                   (Pattern phi (Blank)))\n                ~I4--approx))\n  (wl/eval `(f ~t1 ~t2 ~l1 ~l2 ~phi)))\n\n\n(defn Efield--transmission-phase\n  \"This is just a function to reduce the number of variables over which we plot. We can't (easily) plot in 4-D!\"\n  [[t1 phase]]\n  [t1 phase (Efield t1 t1 20E-6 20E-6 phase)])\n\n\n(wl/eval (w/_= 'nums (mapv Efield--transmission-phase\n                           (coordinates\n                            (math/sqrt 50E-6)\n                            (math/sqrt 700E-6)\n                            -0.001\n                            0.001))))\n\nListPlot3D[nums, Rule[PlotRange, All], Rule[Boxed, False], Rule[AxesLabel, {\"Mirror transmission\", \"Phase\", \"Intracavity intensity\"}]]\nAnd there you have it! It turns out that if you get the phase right and you buy high quality mirrors then you can massively amplify the laser light. In fact, light amplification by the stimulated emission of radiation has a catchier name: it’s called a Laser!",
    "crumbs": [
      "Tutorials for scientists",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Wolframite for scientists II (Cavity physics)</span>"
    ]
  },
  {
    "objectID": "for_developers.index.html",
    "href": "for_developers.index.html",
    "title": "7  Wolframite for developers",
    "section": "",
    "text": "7.1 TL;DR\nWe introduce you, the motivated Clojure developer, to using the Wolfram programming language as a Clojure library. Following some brief inspiration (why on earth should you do this?), and some getting started notes, we outline a ‘real’ workflow using the example of …",
    "crumbs": [
      "Tutorials for developers",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Wolframite for developers</span>"
    ]
  },
  {
    "objectID": "for_developers.index.html#tldr",
    "href": "for_developers.index.html#tldr",
    "title": "7  Wolframite for developers",
    "section": "",
    "text": "Coming soon!\n\nsource: notebooks/for_developers/index.clj",
    "crumbs": [
      "Tutorials for developers",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Wolframite for developers</span>"
    ]
  },
  {
    "objectID": "faq.html",
    "href": "faq.html",
    "title": "8  FAQ",
    "section": "",
    "text": "(ns faq\n  \"Anticipated and, potentially literally, frequently asked questions.\"\n  (:require\n   [scicloj.kindly.v4.kind :as k]))\n\nWhy Wolfram? - From the horse’s mouth:\n\nWolfram Language is a symbolic language, deliberately designed with the breadth and unity needed to develop powerful programs quickly. By integrating high-level forms—like Image, GeoPolygon or Molecule—along with advanced superfunctions—such as ImageIdentify or ApplyReaction—Wolfram Language makes it possible to quickly express complex ideas in computational form.\n\nMore concretely, the Wolfram language, and associated ecosystem, is a powerful way of getting stuff done. As a high-level functional programming language, with more than 6000 functions from across mathematics and data processing, it is sometimes the only practical way of of getting things done. Particularly in explicitly scientific fields. What makes it potentially unique is its place in the Venn diagram of symbolic manipulation, built-in factual and computational knowledge and niche, fully implemented algorithms.\nWhy Wolframite?\n‘Why Wolframite?’ is really just the combination of ‘Why Wolfram?’ (above) and ‘Why Clojure?’.\nIn a nutshell, the Wolfram programming language is ‘best-in-class’ for certain specialist tasks, like manipulating equations, but, to paraphrase (Randall Munroe)[https://xkcd.com/1270/], &gt; Wolfram combines the flexibility and power of abstract mathematics with the intuitive clarity of abstract mathematics.\nClojure, on the other-hand, is a first-class, general-purpose, programming language whose core namespace and dynamical, functional, paradigm is well suited to data exploration and manipulation. So why don’t we call Wolfram from Clojure? It seems like the atypical ‘best of both worlds’.\nTo put it another way, Wolfram is a powerful tool in need of a toolbox. And so what language is best placed to be that ‘box’? Well, Wolfram is, underneath, built on LisP and so will naturally gel more with a similar design philosophy (and way of thinking) than, say, with an object-oriented or scripting language. Furthermore, somewhat ironically, it has a very good ‘link’ to the Java ecosystem. In fact, &gt; For all types of WSTP programs, J/Link provides a higher-level layer of functionality than the traditional C WSTP programming interface. This makes Java the easiest and most convenient language for writing programs to interact with the Wolfram Language.\nEven at a fundamental level therefore, our toolbox language should be a LisP with strong Java interop: mmm…!\nAt the usability layer, Clojure is a well-designed, ergonomic language that leaves its users happy! When it comes to working with mathematical expressions specifically, there are a few key features. First of all, for many people, Clojure was the first language to introduce ergonomic chaining of function expressions, e.g.\n(TeX-&gt;\n   (w/* 'x w/I)\n   (w/+ 'y)\n   ||2)\n. In my view, chaining Wolfram function calls together with threading macros is actually a big usability improvement. Wolfram expressions can get pretty involved (it’s common to end up with expressions that hold 10s of symbols and operators and 100s are not unheard of) and trying to read and manipulate these from the inside out is just not natural for the average human. It stands to reason then that chaining functions together (and debugging them!) can really be a pain. In fact, Wolfram recognised this problem when it introduced the prefix operator, @, to help with function composition, e.g. f@g@h. Unfortunately however, this doesn’t work with multiple arguments. It is possible to do things like f@@args, and even things like f@@@{{a, b}, {c, d}}, but the readability quickly becomes dire. On the other hand, Clojure’s threading is simple, clear and scalable. Secondly, by using a LisP, you are automatically thinking (and evaluating) at the level of the s-expression. This is in contrast to thinking at the level of ‘files’, lines or ‘cells’ of a notebook. This maps very well to the exploration of mathematical expressions. In fact, it’s almost surprising that Wolfram had such a big influence on the idea of notebook-style programming, considering that, at heart, it’s all LisP. In our view, Wolframite brings Wolfram back to a more fundamental form of literate programming.\nWhy literate programming?\nOne of the key motivations of Wolframite is to integrate the power of Wolfram within a more general, more ergonomic programming environment. When it comes to solving complex problems however, it is also important to be able to document and visualise the process. In fact, this is a core part of the academic sciences and consumes a lot of time. Largely however, solving problems and documenting the results have been considered orthogonal processes: duplicating huge amounts of work\nIn contrast, what if &gt; Programs are meant to be read by humans and only incidentally for computers to execute. [D. Knuth]?\nThis is the heart of literate programming.\nThe immediate question that flows from this however, is how? In TeX systems, the answer was to include executable code within running text. In Mathematica, which largely popularized the notebook model, a fully integrated IDE product was built around the underlying language. Jupyter carried on this idea, but universalized the concept by bringing the interaction into the browser.\nAnd yet, for programmers, both of these systems are the wrong way around. The core content and information is in the namespaces and the right level of abstraction is not at arbitrarily chosen cells, but rather evaluation at the level of expressions. Such is the case, a LisP-style evaluation model is one of the biggest advantages of Woframite, particularly when paired with notebooks as a namespace-style literate programming, e.g. clay and clerk. When it comes to analysis, being able to interrogate data interactively is often as, if not more, important than being able to run long simulations. With LisP-style literate programming this becomes even more powerful and the other thing to bear in mind is that with literate programming, the docs double as tests!\nFor more information about the downsides of the notebook-model, have a look at this paper, as cited by the Clerk document system.\nWhy not Emmy?\nYou should use Emmy! Emmy is a fully Clojure(script) symbolic algebra engine that is built on the SCMUTILS system, orginally developed by G.J. Sussman and J. Wisdom. Emmy is a very exciting prospect for symbolic manipulation, but is only a subset of what Wolfram is capable of. In the future, we hope to integrate the two more closely. Our current advice though, is that where you have to do a lot of Solve-ing (i.e. rearranging of equations), or where you need a more powerful simplifier, use Wolframite.\nHow do I translate Mathematica’s syntax sugar?\nSince Mathematica hides the internals of the Wolfram Language by default, it can sometimes be difficult to work out what functions are being called. If you’re in Mathematica, you can use FullForm@Unevaluated[...] to get a more understandable (if less concise) expression. Of course, you can also use Wolframite, i.e. (wl/-&gt; ...) !\n\nsource: notebooks/faq.clj",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>FAQ</span>"
    ]
  }
]